<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Issac Loveless</title>
    <link>/</link>
    <description>Recent content on Issac Loveless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 09 Apr 2020 19:43:38 +0800</lastBuildDate>
    
	<atom:link href="/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Contents</title>
      <link>/contents/</link>
      <pubDate>Thu, 09 Apr 2020 19:43:38 +0800</pubDate>
      
      <guid>/contents/</guid>
      <description>Django   01-Django介绍
 02-Django创建工程
 03-Django的配置
 04-Django的请求与响应
 05-Django配置MySql
 06-Django操作Mysql
 07-Django常用的工具方法
 git   01-git常用指令
 02-git配置代理
 03-git解决push问题
 pygame   01-pygame初始化
 02-pygame中的music
 03-pygame中的color
 04-pygame中的display
 05-pygame中的draw
 06-pygame中的event
 07-pygame中的font
 08-pygame中的image
 09-pygame中的key
 10-pygame中的mouse
 11-pygame中的Surface
 Python   random模块
 数据库   01-数据库Redis配置
 02-数据库Redis操作
 其他   01-Hugo博客编撰日志
 02-MarkDown语法简介
 03-虚拟环境</description>
    </item>
    
    <item>
      <title>Pygame中的Surface</title>
      <link>/blog/pygame/11-pygame%E4%B8%AD%E7%9A%84surface/</link>
      <pubDate>Thu, 09 Apr 2020 01:31:53 +0800</pubDate>
      
      <guid>/blog/pygame/11-pygame%E4%B8%AD%E7%9A%84surface/</guid>
      <description>将一个图像绘制到另一个pygame.Surface.blit
将许多图像绘制到另一个pygame.Surface.blits
更改图像的像素格式pygame.Surface.convert
改变包括每像素α的图像的像素格式pygame.Surface.convert_alpha
创建Surface的新副本pygame.Surface.copy
用纯色填充Surfacepygame.Surface.fill
将表面图像移动到位pygame.Surface.scroll
设置透明颜色键pygame.Surface.set_colorkey
获取当前透明的colorkeypygame.Surface.get_colorkey
设置完整Surface图像的Alpha值pygame.Surface.set_alpha
获取当前的Surface透明度值pygame.Surface.get_alpha
锁定Surface内存以进行像素访问pygame.Surface.lock
从像素访问中解锁Surface存储器pygame.Surface.unlock
测试Surface是否需要锁定pygame.Surface.mustlock
测试Surface是否被当前锁定pygame.Surface.get_locked
获取Surface的锁pygame.Surface.get_locks
获取单个像素的颜色值pygame.Surface.get_at
设置单个像素的颜色值pygame.Surface.set_at
获取单个像素的映射颜色值pygame.Surface.get_at_mapped
获取8位Surface的颜色索引调色板pygame.Surface.get_palette
获取调色板中单个条目的颜色pygame.Surface.get_palette_at
设置8位Surface的调色板pygame.Surface.set_palette
在8位Surface调色板中设置单个索引的颜色pygame.Surface.set_palette_at
将颜色转换为映射的颜色值pygame.Surface.map_rgb
将映射的整数颜色值转换为颜色pygame.Surface.unmap_rgb
设置Surface的当前剪切区域pygame.Surface.set_clip
获取Surface的当前剪切区域pygame.Surface.get_clip
创建一个引用其父级的新表面pygame.Surface.subsurface
找到地下的父母pygame.Surface.get_parent
找到地下的顶级父级pygame.Surface.get_abs_parent
在父母中找到子地下的位置pygame.Surface.get_offset
在其顶级父级中查找子级子表面的绝对位置pygame.Surface.get_abs_offset
获取Surface的尺寸pygame.Surface.get_size
获取Surface的宽度pygame.Surface.get_width
获得Surface的高度pygame.Surface.get_height
得到Surface的矩形区域pygame.Surface.get_rect
获取Surface像素格式的位深度pygame.Surface.get_bitsize
获取每个Surface像素使用的字节数pygame.Surface.get_bytesize 
获取用于Surface的其他标志pygame.Surface.get_flags
获取每个Surface行使用的字节数pygame.Surface.get_pitch
位掩码需要在颜色和映射的整数之间进行转换pygame.Surface.get_masks
设置在颜色和映射整数之间转换所需的位掩码pygame.Surface.set_masks
在颜色和映射的整数之间转换所需的位移pygame.Surface.get_shifts
设置在颜色和映射整数之间转换所需的位移pygame.Surface.set_shifts
用于在颜色和映射整数之间进行转换的有效位pygame.Surface.get_losses
找到包含数据的最小rectpygame.Surface.get_bounding_rect
返回Surface像素的缓冲区视图。pygame.Surface.get_view
获取Surface的像素的缓冲对象。pygame.Surface.get_buffer
像素缓冲地址pygame.Surface._pixels_address</description>
    </item>
    
    <item>
      <title>Pygame中的event</title>
      <link>/blog/pygame/06-pygame%E4%B8%AD%E7%9A%84event/</link>
      <pubDate>Thu, 09 Apr 2020 01:29:09 +0800</pubDate>
      
      <guid>/blog/pygame/06-pygame%E4%B8%AD%E7%9A%84event/</guid>
      <description>内部处理pygame事件处理程序pygame.event.pump
从队列中获取事件pygame.event.get
从队列中获取单个事件pygame.event.poll
等待队列中的单个事件pygame.event.wait
测试事件类型是否在队列中等待pygame.event.peek
从队列中删除所有事件pygame.event.clear
从中获取字符串名称和事件IDpygame.event.event_name
控制队列中允许哪些事件pygame.event.set_blocked
控制队列中允许哪些事件pygame.event.set_allowed
测试是否从队列中阻止了某种类型的事件pygame.event.get_blocked 
控制与其他应用程序共享输入设备pygame.event.set_grab
测试程序是否共享输入设备pygame.event.get_grab
在队列上放置一个新事件pygame.event.post
创建一个新的事件对象pygame.event.Event 
用于表示SDL事件的pygame对象pygame.event.EventType</description>
    </item>
    
    <item>
      <title>Pygame中的display</title>
      <link>/blog/pygame/04-pygame%E4%B8%AD%E7%9A%84display/</link>
      <pubDate>Thu, 09 Apr 2020 01:27:58 +0800</pubDate>
      
      <guid>/blog/pygame/04-pygame%E4%B8%AD%E7%9A%84display/</guid>
      <description>初始化显示模块pygame.display.init
取消初始化显示模块pygame.display.quit
如果已初始化显示模块，则返回Truepygame.display.get_init
初始化窗口或屏幕以进行显示pygame.display.set_mode
获取当前设置的显示表面的参考pygame.display.get_surface
将完整显示Surface更新到屏幕pygame.display.flip
更新屏幕的部分以显示软件pygame.display.update
获取pygame显示后端的名称pygame.display.get_driver
创建视频显示信息对象pygame.display.Info
获取有关当前窗口系统的信息pygame.display.get_wm_info
获取可用的全屏模式列表pygame.display.list_modes
为显示模式选择最佳颜色深度pygame.display.mode_ok
获取当前显示的OpenGL标志的值pygame.display.gl_get_attribute
请求显示模式的OpenGL显示属性pygame.display.gl_set_attribute
当显示器在显示器上处于活动状态时返回Truepygame.display.get_active
图标化显示表面pygame.display.iconify
在全屏和窗口显示之间切换pygame.display.toggle_fullscreen
更改硬件伽玛斜坡pygame.display.set_gamma
使用自定义查找更改硬件伽玛斜坡pygame.display.set_gamma_ramp
更改显示窗口的系统图像pygame.display.set_icon
设置当前窗口标题pygame.display.set_caption
获取当前窗口标题pygame.display.get_caption
设置索引显示的显示调色板pygame.display.set_palette</description>
    </item>
    
    <item>
      <title>Pygame中的font</title>
      <link>/blog/pygame/07-pygame%E4%B8%AD%E7%9A%84font/</link>
      <pubDate>Thu, 09 Apr 2020 01:27:09 +0800</pubDate>
      
      <guid>/blog/pygame/07-pygame%E4%B8%AD%E7%9A%84font/</guid>
      <description>初始化字体模块pygame.font.init
取消初始化字体模块pygame.font.quit
如果字体模块已初始化，则为truepygame.font.get_init
获取默认字体的文件名pygame.font.get_default_font
获取所有可用的字体pygame.font.get_fonts
在系统上找到特定的字体pygame.font.match_font
从系统字体创建一个Font对象pygame.font.SysFont
从文件创建一个新的Font对象pygame.font.Font</description>
    </item>
    
    <item>
      <title>Pygame中的key</title>
      <link>/blog/pygame/09-pygame%E4%B8%AD%E7%9A%84key/</link>
      <pubDate>Thu, 09 Apr 2020 01:26:24 +0800</pubDate>
      
      <guid>/blog/pygame/09-pygame%E4%B8%AD%E7%9A%84key/</guid>
      <description>是否显示正在接收来自系统的键盘输入pygame.key.get_focused
获得所有键盘按钮的状态pygame.key.get_pressed
确定哪些修饰符被持有pygame.key.get_mods
临时设置哪些修饰符键被按下pygame.key.set_mods
控件如何重复控制键pygame.key.set_repeat
查看持有的键是如何重复的pygame.key.get_repeat
得到一个键标识符的名称r(63, 63, 63, 0)pygame.key.name</description>
    </item>
    
    <item>
      <title>Pygame中的draw</title>
      <link>/blog/pygame/05-pygame%E4%B8%AD%E7%9A%84draw/</link>
      <pubDate>Thu, 09 Apr 2020 01:25:13 +0800</pubDate>
      
      <guid>/blog/pygame/05-pygame%E4%B8%AD%E7%9A%84draw/</guid>
      <description>画一个矩形的形状pygame.draw.rect
绘制具有任意数量边的形状pygame.draw.polygon
围绕一个点画一个圆圈pygame.draw.circle
在矩形内绘制圆形pygame.draw.ellipse
绘制椭圆的局部剖面pygame.draw.arc
绘制一条直线段pygame.draw.line
绘制多个连续的线段pygame.draw.lines
绘制精细的抗锯齿线pygame.draw.aaline
绘制连接的抗锯齿线序列pygame.draw.aalines</description>
    </item>
    
    <item>
      <title>Pygame中的image</title>
      <link>/blog/pygame/08-pygame%E4%B8%AD%E7%9A%84image/</link>
      <pubDate>Thu, 09 Apr 2020 01:24:50 +0800</pubDate>
      
      <guid>/blog/pygame/08-pygame%E4%B8%AD%E7%9A%84image/</guid>
      <description>从文件加载新图像pygame.image.load
将图像保存到磁盘pygame.image.save
测试是否可以加载扩展图像格式pygame.image.get_extended
将图像传输到字符串缓冲区pygame.image.tostring
从字符串缓冲区创建新的Surfacepygame.image.fromstring
创建一个在字符串缓冲区内共享数据的新Surfacepygame.image.frombuffer</description>
    </item>
    
    <item>
      <title>Pygame中的mouse</title>
      <link>/blog/pygame/10-pygame%E4%B8%AD%E7%9A%84mouse/</link>
      <pubDate>Thu, 09 Apr 2020 01:22:29 +0800</pubDate>
      
      <guid>/blog/pygame/10-pygame%E4%B8%AD%E7%9A%84mouse/</guid>
      <description>得到鼠标按钮的状态信息pygame.mouse.get_pressed
得到鼠标箭头的位置坐标pygame.mouse.get_pos
获取鼠标移动的数量pygame.mouse.get_rel
设置鼠标箭头的位置坐标pygame.mouse.set_pos
隐藏或者显示鼠标箭头pygame.mouse.set_visible
检查程序是否正在接收来自鼠标的数据pygame.mouse.get_focused
为系统鼠标光标设置图像pygame.mouse.set_cursor
获取系统鼠标光标的图像pygame.mouse.get_cursor</description>
    </item>
    
    <item>
      <title>Pygame中的color</title>
      <link>/blog/pygame/03-pygame%E4%B8%AD%E7%9A%84color/</link>
      <pubDate>Thu, 09 Apr 2020 01:21:24 +0800</pubDate>
      
      <guid>/blog/pygame/03-pygame%E4%B8%AD%E7%9A%84color/</guid>
      <description>得到或设置颜色的红色值pygame.Color.r
得到或设置颜色的绿色值pygame.Color.g
得到或设置颜色的蓝色值pygame.Color.b
得到或设置颜色的透明度pygame.Color.a
获取或设置cmy表示颜色pygame.Color.cmy
获取或设置hsva表示的颜色pygame.Color.hsva
获取或设置hsla表示颜色pygame.Color.hsla
获取或设置i1i2i3表示颜色pygame.Color.i1i2i3
返回规范化的RGBA值pygame.Color.normalize
对颜色应用一个特定的伽马值pygame.Color.correct_gamma
将颜色的元素设置为1,2,3或4pygame.Color.set_length</description>
    </item>
    
    <item>
      <title>Pygame中的music</title>
      <link>/blog/pygame/02-pygame%E4%B8%AD%E7%9A%84music/</link>
      <pubDate>Thu, 09 Apr 2020 01:20:17 +0800</pubDate>
      
      <guid>/blog/pygame/02-pygame%E4%B8%AD%E7%9A%84music/</guid>
      <description>加载一个用于播放的音乐文件pygame.mixer.music.load
开始播放音乐流pygame.mixer.music.play
重新启动音乐pygame.mixer.music.rewind
停止播放音乐pygame.mixer.music.stop
暂停音乐播放pygame.mixer.music.pause
恢复暂停的音乐pygame.mixer.music.unpause
在淡出后停止播放音乐pygame.mixer.music.fadeout
设置音量pygame.mixer.music.set_volume
获取音乐音量pygame.mixer.music.get_volume
检查音乐流是否在播放pygame.mixer.music.get_busy
设置的位置pygame.mixer.music.set_pos
获得音乐播放时间pygame.mixer.music.get_pos
队列一个音乐文件以跟随当前pygame.mixer.music.queue
当播放停止时，音乐会发送一个事件pygame.mixer.music.set_endevent
当播放停止时，获取一个通道发送的事件pygame.mixer.music.get_endevent</description>
    </item>
    
    <item>
      <title>05 键值对应关系表</title>
      <link>/blog/%E5%85%B6%E4%BB%96/05-%E9%94%AE%E5%80%BC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E8%A1%A8/</link>
      <pubDate>Thu, 09 Apr 2020 00:40:45 +0800</pubDate>
      
      <guid>/blog/%E5%85%B6%E4%BB%96/05-%E9%94%AE%E5%80%BC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E8%A1%A8/</guid>
      <description>KeyASCII ASCII Common Name     KeyASCII ASCII Common Name   K_BACKSPACE \b backspace   K_TAB \t tab   K_CLEAR  clear   K_RETURN \r return   K_PAUSE  pause   K_ESCAPE ^[ escape   K_SPACE  space   K_EXCLAIM ! exclaim   K_QUOTEDBL &amp;quot; quotedbl   K_HASH # hash   K_DOLLAR $ dollar   K_AMPERSAND &amp;amp; ampersand   K_QUOTE  quote   K_LEFTPAREN ( left parenthesis   K_RIGHTPAREN ) right parenthesis   K_ASTERISK * asterisk   K_PLUS + plus sign   K_COMMA , comma   K_MINUS - minus sign   K_PERIOD .</description>
    </item>
    
    <item>
      <title>Random模块</title>
      <link>/blog/python/random%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Thu, 09 Apr 2020 00:27:13 +0800</pubDate>
      
      <guid>/blog/python/random%E6%A8%A1%E5%9D%97/</guid>
      <description>random 是 Python 内置的一个模块，包括以下方法：
 初始化伪随机数生成器。如果未提供as或者a=None，则使用系统时间为种子。如果a是一个整数，则作为种子。  random.seed(a=None, version=2)
 返回一个当前生成器的内部状态的对象  random.getstate()
 传入一个先前利用getstate方法获得的状态对象，使得生成器恢复到这个状态。  random.setstate(state)
 返回range(0,2**k)之间的一个整数，相当于randrange(0,\2**k)  random.getrandbits(k)
 返回range(0,stop)之间的一个整数  random.randrange(stop)
 返回range[start,stop)之间的一个整数，可加step，跟range(0,10,2)类似  random.randrange(start, stop[, step])
 返回range[a,b]之间的一个整数，等价于然的range(a,b+1)  random.randint(a, b)
 从非空序列seq中随机选取一个元素。如果seq为空则弹出 IndexError异常。  random.choice(seq)
 3.6版本新增。从population集群中随机抽取K个元素（可重复）。weights是相对权重列表，cum_weights是累计权重，两个参数不能同时存在。  random.choices(population, weights=None, *, cum_weights=None, k=1)
 随机打乱序列x内元素的排列顺序。只能针对可变的序列，对于不可变序列，请使用下面的sample()方法。  random.shuffle(x[, random])
 从population样本或集合中随机抽取K个不重复的元素形成新的序列。常用于不重复的随机抽样。返回的是一个新的序列，不会破坏原有序列。要从一个整数区间随机抽取一定数量的整数，请使用sample(range(10000000), k=60)类似的方法，这非常有效和节省空间。如果k大于population的长度，则弹出ValueError异常。  random.sample(population, k)
 返回一个介于左闭右开[0.0, 1.0)区间的浮点数  random.random()
 返回一个介于a和b之间的浮点数。如果a&amp;gt;b，则是b到a之间的浮点数。这里的a和b都有可能出现在结果中。  random.uniform(a, b)</description>
    </item>
    
    <item>
      <title>Pygame初始化</title>
      <link>/blog/pygame/01-pygame%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Wed, 08 Apr 2020 19:51:49 +0800</pubDate>
      
      <guid>/blog/pygame/01-pygame%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>这是一套pygame的自用初始化模板，这个“游戏”的唯一功能就是按方向键的时候，“退出游戏”按钮可以动。
#初始化 import pygame,sys,configparser from pygame.locals import * pygame.init() #载入脚本 parser = configparser.ConfigParser() parser.read(&#39;rules.ini&#39;, encoding=&#39;gbk&#39;) #设置帧率 Fps = 60 fpsClock = pygame.time.Clock() #创建窗口 WindowsWidth = 1920 WindowsHeight = 1080 DisplaySurf = pygame.display.set_mode((WindowsWidth,WindowsHeight),FULLSCREEN|HWSURFACE,32) pygame.set_caption = &#39;初始化&#39; #颜色管理 White = (255,255,255,0) Green = (100,210,100,0) Blue = (100,100,210,50) Black = (0,0,0,0) Orange = (210,150,50,0) #设置背景 DisplaySurf.fill(White) #导入图片 coverImg = pygame.image.load(&#39;cover.png&#39;).convert_alpha() btStartGame = pygame.image.load(&#39;bt001.png&#39;).convert_alpha() btExitGame = pygame.image.load(&#39;bt002.png&#39;) CoverGlass = pygame.image.load(&#39;glass.png&#39;) cursorImg = pygame.image.load(&#39;cursor.png&#39;).convert_alpha() cursorLinkImg = pygame.</description>
    </item>
    
    <item>
      <title>Py转exe</title>
      <link>/blog/%E5%85%B6%E4%BB%96/04-py%E8%BD%ACexe/</link>
      <pubDate>Wed, 08 Apr 2020 19:44:46 +0800</pubDate>
      
      <guid>/blog/%E5%85%B6%E4%BB%96/04-py%E8%BD%ACexe/</guid>
      <description>py是解释型语言，只能在配有python的环境下才能运行，只有将py文件打包，才能在更多系统中运行。
py转exe pyinstaller -F --icon=my.ico XXXX.py
 –icon=图标路径（）
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
 pyqt5写完win32 应用程序后，经过pyinstaller打包成单个文件，运行弹出错误提示框：
failed to execute script main
pycharm中pyinstaller打包参数：
Program:C:\Python\Python35\Scripts\pyinstaller.exe
Parameters: -w -F $FileName$
Working directory: $FileDir$
分析： 经google，发现pyinstaller 有&amp;ndash;hidden-import 选项 &amp;ndash;hidden-import MODULENAME, &amp;ndash;hiddenimport MODULENAME Name an import not visible in the code of the script(s). This option can be used multiple times.
解决： 打包时加上 --hidden-import=queue
即Parameters配置修改为：
Parameters:--hidden-import=queue -w -F $FileName$
eg:
pyinstaller --hidden-import=queue -w -F main.</description>
    </item>
    
    <item>
      <title>Resume</title>
      <link>/resume/resume/</link>
      <pubDate>Wed, 08 Apr 2020 16:31:50 +0800</pubDate>
      
      <guid>/resume/resume/</guid>
      <description>随机字符串</description>
    </item>
    
    <item>
      <title>数据库Redis操作</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/02-%E6%95%B0%E6%8D%AE%E5%BA%93redis%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 08 Apr 2020 15:08:30 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/02-%E6%95%B0%E6%8D%AE%E5%BA%93redis%E6%93%8D%E4%BD%9C/</guid>
      <description>Redis的详细操作方法，针对五种不同数据类型的增删改查
 String 字符串类型的数据存取
set(name, value, ex=None, px=None, nx=False, xx=False)
 相关参数：
 ex，过期时间（秒）
px，过期时间（毫秒）
nx，如果设置为True，则只有name不存在时，当前set操作才执行
xx，如果设置为True，则只有name存在时，当前set操作才执行
  r.set(&#39;name&#39;, &#39;Issac&#39;) # key是&amp;quot;foo&amp;quot; value是&amp;quot;bar&amp;quot; 将键值对存入redis缓存 r.get(&#39;name&#39;)    只有name不存在时，才执行set操作（添加）
 r.setnx(name, value) print(r.setnx(&#39;name&#39;, &#39;Issac&#39;)) # fruit1不存在，输出为True，存在输出为None    time，过期时间（int秒 或 timedelta对象）,psetex()的参数相同，单位是毫秒。
r.setex(name, time, value)
  批量设置
 r.mget({&#39;k1&#39;: &#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;}) r.mset(name = &amp;quot;issac&amp;quot;, age=26, height=190)    批量获取
r.mget(&#39;name&#39;, &#39;age&#39;, &#39;height&#39;)
  设置新值并获取原来的值
print(r.getset(&amp;quot;name&amp;quot;, &amp;quot;Missty&amp;quot;)) # 设置的新值是Missty 设置前的值是Issac</description>
    </item>
    
    <item>
      <title>Redis配置</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/01-%E6%95%B0%E6%8D%AE%E5%BA%93redis%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 08 Apr 2020 14:47:44 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/01-%E6%95%B0%E6%8D%AE%E5%BA%93redis%E9%85%8D%E7%BD%AE/</guid>
      <description>Redis是一个开源的使用ANSIC语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。
 特点  redis最大的特点在于其效率极高。
   读的速度是110000次/s
写的速度是81000次/s。
   支持多种数据结构
   string（字符串）
list(双向链表)
dict(hash表)
set(集合）
zset(有序集合)
   支持持久化操作
 局限性  Redis只能使用单线程，性能受限于CPU性能 Mc和Redis都是Key-Value类型，不适合在不同数据集之间建立关系，也不适合进行查询搜索。
 Python与Redis的交互操作，借用python中的redis模块。
import redis
该模块中封装的方法名称、使用规则与原生的redis语法几乎一致。
定义地址和端口 host = &#39;127.0.0.1&#39; port = 6379  建立redis连接 r = redis.Redis(host=host,port=port)  </description>
    </item>
    
    <item>
      <title>Django常用的工具方法</title>
      <link>/blog/django/07-django%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 08 Apr 2020 13:54:16 +0800</pubDate>
      
      <guid>/blog/django/07-django%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/</guid>
      <description>原生sql结果集美化，获取ip，redis链接，验证token，类方法装饰器，七牛云秘钥接口，立体中文水印，PIL绘制验证码，MD5加密方法
 Django中复用率较高的代码
针对原生sql语句的结果集美化方法 from pymongo import MongoClient m = MongoClient() md_db = m.mdshop # 对结果集美化方法 def dict_fetchall(cursor): # 获取游标描述 desc = cursor.description return [ dict(zip( [col[0] for col in desc], row )) for row in cursor.fetchall() ]  获取ip # 获取ip def getIp(request): # 获取IP if &#39;HTTP_X_FORWARDED_FOR&#39; in request.META: ip = request.META(&#39;HTTP_X_FORWARDED_FOR&#39;) else: ip = request.META.get(&#39;REMOTE_ADDR&#39;) return ip  redis链接 import redis # 定义ip 和端口 host = &#39;127.0.0.1&#39; port = 6379 # 建立连接 r = redis.</description>
    </item>
    
    <item>
      <title>Django操作Mysql</title>
      <link>/blog/django/06-django%E6%93%8D%E4%BD%9Cmysql/</link>
      <pubDate>Wed, 08 Apr 2020 12:08:08 +0800</pubDate>
      
      <guid>/blog/django/06-django%E6%93%8D%E4%BD%9Cmysql/</guid>
      <description>Django中orm框架的使用方法，包括数据库的增删改查，对结果集的处理。
 数据库的增删改查，在orm下的实现方法
1. 增加   save()  user = User(username=&#39;Issac&#39;, password=&#39;123&#39;) user.save()    create()  User.objects.create(username=&#39;Missty&#39;, password=&#39;456&#39;)     2. 删除   delete()  User.objects.get(id=1).delete()     3. 修改   save()  user = User.objects.filter(name=&#39;Issac&#39;).first() user.name=&#39;Loveless&#39; user.save()    update()  User.objects.filter(name=&#39;Arissa&#39;).update(name=&#39;Inverse&#39;)    4. 查询 4.1 基本查询   get()    如果不存在会抛出模型类.DoesNotExist异常
  User.objects.get(id=1)    all()  User.</description>
    </item>
    
    <item>
      <title>Django配置MySql</title>
      <link>/blog/django/05-django%E9%85%8D%E7%BD%AEmysql/</link>
      <pubDate>Wed, 08 Apr 2020 10:23:18 +0800</pubDate>
      
      <guid>/blog/django/05-django%E9%85%8D%E7%BD%AEmysql/</guid>
      <description>Django 中的orm框架如何实现MySql数据库的增删改查，更新了自动添加创建时间的功能
 1. 数据库配置 在settings.py中的DATABASE里保存了数据库的连接配置信息。
使用MySQL数据库首先需要安装驱动程序。 pip install PyMySQL
在Django的工程同名子目录的__init__.py文件中添加如下语句 from pymysql import install_as_MySQLdb install_as_MySQLdb()  作用是让Django的ORM能以mysqldb的方式来调用PyMySQL。
修改DATABASES配置信息 DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;, &#39;HOST&#39;: &#39;127.0.0.1&#39;, # 数据库主机 &#39;PORT&#39;: 3306, # 数据库端口 &#39;USER&#39;: &#39;root&#39;, # 数据库用户名 &#39;PASSWORD&#39;: &#39;mysql&#39;, # 数据库用户密码 &#39;NAME&#39;: &#39;django_demo&#39; # 数据库名字 } }  在MySQL中创建数据库 create database django_demo default charset=utf8;   2. Models 定义模型类
 模型类被定义在&amp;quot;应用/models.py&amp;quot;文件中。 模型类必须继承自Model类，位于包django.db.models中。  1) 定义 在models.py中定义模型 orm框架：创建表和字段
from django.db import models #定义用户模型类User class User(models.</description>
    </item>
    
    <item>
      <title>Django的请求与响应</title>
      <link>/blog/django/04-django%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/</link>
      <pubDate>Wed, 08 Apr 2020 09:22:50 +0800</pubDate>
      
      <guid>/blog/django/04-django%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/</guid>
      <description>请求request和响应response
 1, 请求 GET和POST请求 request中包含GET和POST属性，来接收相应请求方法传来的数据。
from django.views import View class Sample(View): def get(self, request): # 获取参数 params = request.GET params.get(key) def post(self, request): # 获取参数 data = request.POST params.get(key)  其他请求 这种方式是解析request.body，泛用性很高。
from django.views import View class Sample(View): def put(self,request): # 整理数据 put = QueryDict(request.body) put_str = list(put.items())[0][0] put_dict = eval(put_str).get(&#39;data&#39;) # 获取参数 put_dict.get(key)  请求头  CONTENT_LENGTH – The length of the request body (as a string). CONTENT_TYPE – The MIME type of the request body.</description>
    </item>
    
    <item>
      <title>Django的配置</title>
      <link>/blog/django/03-django%E7%9A%84%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 08 Apr 2020 09:07:05 +0800</pubDate>
      
      <guid>/blog/django/03-django%E7%9A%84%E9%85%8D%E7%BD%AE/</guid>
      <description>配置文件settings中的一些基础设置。
 1. 配置文件 Django将环境变量集成在settings.py中，可以在该文件里修改相关的配置。
1) BASE_DIR BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
当前工程的根目录，Django会依此来定位工程内的相关文件，我们也可以使用该参数来构造文件路径。
2) DEBUG 调试模式，创建工程后初始值为True，即默认工作在调试模式下。
 修改代码文件，程序自动重启 Django程序出现异常时，向前端显示详细的错误追踪信息 注意：部署线上运行的Django不要运行在调式模式下，记得修改DEBUG=False。  3) 语言与时区 Django支持本地化处理，即显示语言与时区支持本地化。初始化的工程默认语言和时区为英语和UTC标准时区，中国大陆地区使用简体中文，时区使用亚洲/上海时区，注意这里不使用北京时区表示。
LANGUAGE_CODE = &#39;zh-hans&#39; TIME_ZONE = &#39;Asia/Shanghai&#39;   2. 静态文件 项目中的CSS、图片、js都是静态文件。一般会将静态文件放到一个单独的目录中，以方便管理。
在html页面中调用时，也需要指定静态文件的路径，Django中提供了一种解析的方式配置静态文件路径。静态文件可以放在项目根目录下，也可以放在应用的目录下，由于有些静态文件在项目中是通用的，所以推荐放在项目的根目录下，方便管理。
为了提供静态文件，需要配置两个参数：
  STATICFILES_DIRS 存放查找静态文件的目录
  STATIC_URL 访问静态文件的URL前缀
STATIC_URL = &amp;lsquo;/static/&amp;rsquo; STATICFILES_DIRS = [ os.path.join(BASE_DIR, &amp;lsquo;static_files&amp;rsquo;), ]
  此时在static_files添加的任何静态文件都可以使用网址/static/文件在static_files中的路径来访问。
例如： http://localhost:8000/static/logo.png
 注意
  Django 仅在调试模式下（DEBUG=True）能对外提供静态文件。
  当DEBUG=False工作在生产模式时，Django不再对外提供静态文件，需要是用collectstatic命令来收集静态文件并交由其他静态文件服务器来提供。
  </description>
    </item>
    
    <item>
      <title>Django初始化</title>
      <link>/blog/django/02-django%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B/</link>
      <pubDate>Wed, 08 Apr 2020 08:36:40 +0800</pubDate>
      
      <guid>/blog/django/02-django%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B/</guid>
      <description>Django初始化一个项目要进行的素质三连
 1. 创建项目 创建工程的命令为：
django-admin startproject 工程名称
运行开发服务器 在开发阶段，为了能够快速预览到开发的效果，django提供了一个纯python编写的轻量级web服务器，仅在开发阶段使用。
运行服务器命令为：
python manage.py runserver ip:端口 或： python manage.py runserver  可以不写IP和端口，默认IP是127.0.0.1，默认端口为8000。
 django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启。 按ctrl+c停止服务器。   2. 创建子应用 在Web应用中，通常有一些业务功能模块是在不同的项目中都可以复用的，故在开发中通常将工程项目拆分为不同的子功能模块，各功能模块间可以保持相对的独立，在其他工程项目中需要用到某个特定功能模块时，可以将该模块代码整体复制过去，达到复用。
类似于Flask中的蓝图Blueprint。
Django的视图编写是放在子应用中的。
创建 python manage.py startapp 子应用名称
manage.py 为上述创建工程时自动生成的管理文件。
 admin.py 文件跟网站的后台管理站点配置相关。 apps.py 文件用于配置当前子应用的相关信息。 migrations 目录用于存放数据库迁移历史文件。 models.py 文件用户保存数据库模型类。 tests.py 文件用于开发测试用例，编写单元测试。 views.py 文件用于编写Web应用视图。  注册安装子应用 创建出来的子应用目录文件虽然被放到了工程项目目录中，但是django工程并不能立即直接使用该子应用，需要注册安装后才能使用。
在工程配置文件settings.py中，INSTALLED_APPS项保存了工程中已经注册安装的子应用。注册安装一个子应用的方法，即是将子应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。
例如，将刚创建的users子应用添加到工程中，可在INSTALLED_APPS列表中添加&amp;rsquo;users.apps.UsersConfig&amp;rsquo;。
 3. 创建视图 Django的视图是定义在子应用的views.py中的。
创建 打开刚创建的users模块，在views.py中编写视图代码。
from django.http import HttpResponse def index(request): &amp;quot;&amp;quot;&amp;quot; :request: 包含了请求信息的请求对象 :return: 响应对象 &amp;quot;&amp;quot;&amp;quot; return HttpResponse(&amp;quot;hello the world!</description>
    </item>
    
    <item>
      <title>虚拟环境</title>
      <link>/blog/%E5%85%B6%E4%BB%96/03-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 08 Apr 2020 08:27:39 +0800</pubDate>
      
      <guid>/blog/%E5%85%B6%E4%BB%96/03-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid>
      <description>虚拟环境是在计算机硬盘中独立开辟出的一部分空间，在这里可以安装和外部环境不同版本的框架，不与外界冲突。
 虚拟环境是在计算机硬盘中独立开辟出的一部分空间，在这里可以安装和外部环境不同版本的框架，不与外界冲突。针对于需要不同版本环境的项目，可以搭建相应的虚拟环境。
1. 创建虚拟环境 mkvirtualenv django_py3_1.11 -p python3
2. 虚拟环境常用指令 # 虚拟环境 mkvirtualenv # 创建虚拟环境 rmvirtualenv # 删除虚拟环境 workon # 进入虚拟环境、查看所有虚拟环境 deactivate # 退出虚拟环境 </description>
    </item>
    
    <item>
      <title>Django介绍</title>
      <link>/blog/django/01-django%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 08 Apr 2020 08:13:14 +0800</pubDate>
      
      <guid>/blog/django/01-django%E4%BB%8B%E7%BB%8D/</guid>
      <description>Django在近年来的迅速发展，应用越来越广泛，被著名IT开发杂志SDTimes评选为2013SDTimes100，位列&amp;quot;API、库和框架&amp;quot;分类第6位，被认为是该领域的佼佼者。
 1. 简介 Django，发音为[`dʒæŋɡəʊ]，是用python语言写的开源web开发框架，并遵循MVC设计。劳伦斯出版集团为了开发以新闻内容为主的网站，而开发出来了这个框架，于2005年7月在BSD许可证下发布。这个名称来源于比利时的爵士音乐家DjangoReinhardt，他是一个吉普赛人，主要以演奏吉它为主，还演奏过小提琴等。由于Django在近年来的迅速发展，应用越来越广泛，被著名IT开发杂志SDTimes评选为2013SDTimes100，位列&amp;quot;API、库和框架&amp;quot;分类第6位，被认为是该领域的佼佼者。
Django的主要目的是简便、快速的开发数据库驱动的网站。它强调代码复用，多个组件可以很方便的以&amp;quot;插件&amp;quot;形式服务于整个框架，Django有许多功能强大的第三方插件，你甚至可以很方便的开发出自己的工具包。这使得Django具有很强的可扩展性。它还强调快速开发和DRY(DoNotRepeatYourself)原则。
 2. 特点  提供项目工程管理的自动化脚本工具 数据库ORM支持（对象关系映射，英语：Object Relational Mapping） 模板 表单 Admin管理站点 文件管理 认证权限 session机制 缓存   本博客提供的Django教程为前后端开发。结合vue使用的部分，且为no_session系统。于此无关者一切从简。
# 点击查看Django文档 </description>
    </item>
    
    <item>
      <title>Markdown语法简介</title>
      <link>/blog/%E5%85%B6%E4%BB%96/02-markdown%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 07 Apr 2020 23:33:18 +0800</pubDate>
      
      <guid>/blog/%E5%85%B6%E4%BB%96/02-markdown%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</guid>
      <description>MarkDown
 Markdown 的超简短语法介绍 标题 普通文字
图片 本地图片 网络图片 链接 本站
代码 code
MarkDown 的 11 种基本语法   标题设置（让字体变大，和word的标题意思一样） 在Markdown当中设置标题，有两种方式： 第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。 第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）
  块注释（blockquote） 通过在文字开头添加“&amp;gt;”表示块注释。（当&amp;gt;和文字之间添加五个blank时，块注释的文字会有变化。）
  斜体 将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来
  粗体 将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来
  无序列表 在文字开头添加(, +, and -)实现无序列表。但是要注意在(, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）
  有序列表 使用数字后面跟上句号。（还要有空格）
  链接（Links）
Markdown中有两种方式，实现链接，分别为内联方式和引用方式。
内联方式：This is an example link.
引用方式：
 I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].</description>
    </item>
    
    <item>
      <title>Hugo博客编撰日志</title>
      <link>/blog/%E5%85%B6%E4%BB%96/01-hugo%E5%8D%9A%E5%AE%A2%E7%BC%96%E6%92%B0%E6%97%A5%E5%BF%97/</link>
      <pubDate>Tue, 07 Apr 2020 23:20:16 +0800</pubDate>
      
      <guid>/blog/%E5%85%B6%E4%BB%96/01-hugo%E5%8D%9A%E5%AE%A2%E7%BC%96%E6%92%B0%E6%97%A5%E5%BF%97/</guid>
      <description>该博客的撰写轨迹
 创建新项目 hugo new site missbless
 下载主题 https://themes.gohugo.io/
如果是手动下载，解压缩后删除文件夹后面的 -master
 配置主题 进入\themes\hugo-future-imperfect-slim\exampleSite，复制 data, resources, static, config.toml 到根目录
 启动项目 hugo server
 创建文件 hugo new 文件夹/文件名.md
 MarkDown语法 MarkDown语法
 修改默认设置 修改archetypes/default.md，来编辑默认的模板
 自动生成目录 &#39;&#39;&#39; 这个脚本用来实现自动生成分级目录，项目打包，自动替换打包后的简历文件，配置代理并上传到github &#39;&#39;&#39; import os dir_list = os.listdir(&#39;./content/blog/&#39;) dir_list.remove(&#39;其他&#39;) dir_list.append(&#39;其他&#39;) from datetime import datetime # 写入头部 date = &amp;quot;%sT%s&amp;quot;%(datetime.now().date(), datetime.now().time()) date = date.split(&#39;.&#39;,-1)[0] + &#39;+08:00&#39; head = &amp;quot;---\ntitle: &#39;Contents&#39;\ndate: %s\n---\n&amp;quot;%date with open(&#39;./content/Contents.md&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f: f.</description>
    </item>
    
    <item>
      <title>Git常用指令</title>
      <link>/blog/git/01-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Mon, 06 Apr 2020 20:35:10 +0800</pubDate>
      
      <guid>/blog/git/01-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</guid>
      <description>git config --system --unset credential.helper
清空账户密码配置
git config --global credential.helper store
保存账户密码
git checkout .
没有add的时候回退修改
git reset HEAD
add到暂存区之后回退
git log
复制第二个id
git reset --hard
粘贴
git commit之后回退</description>
    </item>
    
    <item>
      <title>Git配置代理</title>
      <link>/blog/git/02-git%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</link>
      <pubDate>Mon, 06 Apr 2020 20:30:12 +0800</pubDate>
      
      <guid>/blog/git/02-git%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</guid>
      <description>配置代理：
git config --global http.proxy http://127.0.0.1:1087
git config --global https.proxy https://127.0.0.1:1087
解除配置
git config --global --unset http.proxy
git config --global --unset https.proxy</description>
    </item>
    
    <item>
      <title>git解决push问题</title>
      <link>/blog/git/03-git%E8%A7%A3%E5%86%B3push%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 06 Apr 2020 19:00:52 +0800</pubDate>
      
      <guid>/blog/git/03-git%E8%A7%A3%E5%86%B3push%E9%97%AE%E9%A2%98/</guid>
      <description>&#39;&amp;rsquo;&amp;rsquo; hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: &amp;lsquo;git pull &amp;hellip;&#39;) before pushing again. hint: See the &amp;lsquo;Note about fast-forwards&amp;rsquo; in &amp;lsquo;git push &amp;ndash;help&amp;rsquo; for details.
解决办法： git push -u origin master -f</description>
    </item>
    
  </channel>
</rss>