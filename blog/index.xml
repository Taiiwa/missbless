<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blog on Issac Loveless</title>
    <link>/blog/</link>
    <description>Recent content in Blog on Issac Loveless</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 02 Jun 2020 19:51:09 +0800</lastBuildDate>
    
	<atom:link href="/blog/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Element上传头像到七牛云</title>
      <link>/blog/vue/03-element%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91/</link>
      <pubDate>Tue, 02 Jun 2020 19:51:09 +0800</pubDate>
      
      <guid>/blog/vue/03-element%E4%B8%8A%E4%BC%A0%E5%A4%B4%E5%83%8F%E5%88%B0%E4%B8%83%E7%89%9B%E4%BA%91/</guid>
      <description>&amp;lt;template&amp;gt; &amp;lt;el-upload class=&amp;quot;avatar-uploader&amp;quot; :auto-upload=&amp;quot;true&amp;quot; :data=&#39;qiniuData&#39; action=&amp;quot;http://up-z1.qiniu.com&amp;quot; :show-file-list=&amp;quot;false&amp;quot; :on-success=&amp;quot;handleAvatarSuccess&amp;quot; :before-upload=&amp;quot;beforeAvatarUpload&amp;quot;&amp;gt; &amp;lt;img v-if=&amp;quot;imageUrl&amp;quot; :src=&amp;quot;imageUrl&amp;quot; class=&amp;quot;avatar&amp;quot;&amp;gt; &amp;lt;i v-else class=&amp;quot;el-icon-plus avatar-uploader-icon&amp;quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/el-upload&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import { uptoken_get } from &amp;quot;../axios_api/api&amp;quot;; export default { data() { return { imageUrl: &amp;quot;&amp;quot;, qiniuData: { //上传图片携带的参数 token: &amp;quot;&amp;quot;, key: &amp;quot;&amp;quot; }, } }, mounted() { this.get_uptoken(); }, methods:{ // 生成uuid作为图片key guid2() { function S4() { return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1); } return ( S4() + S4() +&amp;quot;-&amp;quot; +S4() +&amp;quot;-&amp;quot; +S4() + &amp;quot;-&amp;quot; + S4() + &amp;quot;-&amp;quot; + S4() + S4() + S4() ); }, // 获取七牛云凭证 get_uptoken() { uptoken_get().</description>
    </item>
    
    <item>
      <title>Django的生产环境部署WSGI_nginx</title>
      <link>/blog/django/14-django%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2wsgi_nginx/</link>
      <pubDate>Tue, 02 Jun 2020 19:38:10 +0800</pubDate>
      
      <guid>/blog/django/14-django%E7%9A%84%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2wsgi_nginx/</guid>
      <description>django生产环境部署 生产环境中的数据流 参考文档：
wsgi详解：https://blog.csdn.net/li_101357/article/details/52748323
wsgi协议介绍（萌新版）：https://blog.csdn.net/j163you/article/details/80919360
廖雪峰web编程讲解：https://www.liaoxuefeng.com/wiki/897692888725344/923057027806560
WSGI是什么？   WSGI是一种规范，它定义了使用python编写的web app(django)与web server（uWSGI）之间接口格式，实现web app与web server间的解耦。
  WSGI 没有官方的实现, 因为WSGI更像一个协议. 只要遵照这些协议,WSGI应用(Application)都可以在任何服务器(Server)上运行
  WSGI实质：WSGI是一种描述web服务器（如nginx，uWSGI等服务器）如何与web应用程序（如用Django、Flask框架写的程序）通信的规范、协议。
  为什么需要web协议：
　1）不同的框架有不同的开发方式，但是无论如何，开发出的应用程序都要和服务器程序配合，才能为用户提供服务。
　2） 这样，服务器程序就需要为不同的框架提供不同的支持,只有支持它的服务器才能被开发出的应用使用，显然这是不可行的。
　3）**web协议本质：**就是定义了Web服务器和Web应用程序或框架之间的一种简单而通用的接口规范。
Web协议介绍
　Web协议出现顺序： CGI -&amp;gt; FCGI -&amp;gt; WSGI -&amp;gt; uwsgi
　1. CGI： 最早的协议
　2. FCGI： 比CGI快
　3. WSGI： Python专用的协议 4. uwsgi： 比FCGI和WSGI都快，是uWSGI项目自有的协议，主要特征是采用二进制来存储数据， 议都是使用字符串，所以在存储空间和解析速度上，都优于字符串型协议.
uwsgi是什么？  它是一个二进制协议，可以携带任何类型的数据。 一个uwsgi分组的头4个字节描述了这个分组包含的数据类型。 uwsgi是一种线路协议而不是通信协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信；  uWSGI是什么？（web服务器 和nginx类似）   什么是uWSGI： uWSGI是一个全功能的HTTP服务器，实现了WSGI协议、uwsgi协议、http协议等。</description>
    </item>
    
    <item>
      <title>多版本python下的pip安装与指令</title>
      <link>/blog/python/%E5%A4%9A%E7%89%88%E6%9C%ACpython%E4%B8%8B%E7%9A%84pip/</link>
      <pubDate>Mon, 01 Jun 2020 08:06:42 +0800</pubDate>
      
      <guid>/blog/python/%E5%A4%9A%E7%89%88%E6%9C%ACpython%E4%B8%8B%E7%9A%84pip/</guid>
      <description>多版本Python下pip安装 sudo apt-get install python-pip
sudo apt-get install python3-pip
如果是卸载，将install替换成remove
多版本Python下pip使用 在一个环境中同时装有python2 和python3
使用python3版本，要在pip指令前加上python3 -m
更改源 临时使用
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package
设为默认
pip install -i https://pypi.tuna.tsinghua.edu.cn/simple pip -U
pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple
pip命令 可以通过pip指令查看所有命令。
在线安装
pip install 包名
从requirements.txt安装
pip install -r requirements.txt
通过使用== &amp;gt;= &amp;lt;= &amp;gt; &amp;lt;来指定版本，不写则安装最新版
安装本地安装包
pip install &amp;lt;目录&amp;gt;/&amp;lt;文件名&amp;gt; 或 pip install --use-wheel --no-index --find-links=wheelhouse/ &amp;lt;包名&amp;gt;
卸载安装包
pip uninstall &amp;lt;包名&amp;gt; 或 pip uninstall -r requirements.</description>
    </item>
    
    <item>
      <title>Os模块</title>
      <link>/blog/python/os%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 25 May 2020 00:39:26 +0800</pubDate>
      
      <guid>/blog/python/os%E6%A8%A1%E5%9D%97/</guid>
      <description>os.getcwd()
获取当前工作目录，即当前python脚本工作的目录路径
 os.chdir(&amp;ldquo;dirname&amp;rdquo;) 改变当前脚本工作目录；相当于shell下cd
 os.curdir 返回当前目录: (&#39;.&#39;)
 os.pardir 获取当前目录的父目录字符串名：(&#39;..&#39;)
 os.makedirs(&amp;lsquo;dirname1/dirname2&amp;rsquo;) 可生成多层递归目录
 os.removedirs(&amp;lsquo;dirname1&amp;rsquo;)
若目录为空，则删除，并递归到上一级目录，如若也为空，则删除，依此类推
注:makedirs()和removedirs()是一组相反的函数,一个创建一个删除(针对多个层级文件操作) os.mkdir(&amp;lsquo;dirname&amp;rsquo;)
生成单级目录；相当于shell中mkdir dirname
 os.rmdir(&amp;lsquo;dirname&amp;rsquo;)
删除单级空目录，若目录不为空则无法删除，报错；相当于shell中rmdir dirname
 os.remove() 删除一个文件注:mkdir()和remove()是一组相反的函数,一个创建一个删除(针对单个层级文件操作) os.listdir(&amp;lsquo;dirname&amp;rsquo;)
列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
 os.rename(&amp;ldquo;oldname&amp;rdquo;,&amp;ldquo;newname&amp;rdquo;) 重命名文件/目录
 os.stat(&amp;lsquo;path/filename&amp;rsquo;)
获取文件/目录信息
 os.sep
输出操作系统特定的路径分隔符，win下为&amp;rdquo;\&amp;quot;,Linux下为&amp;rdquo;/&amp;rdquo;
 os.linesep
输出当前平台使用的行终止符，win下为&amp;rdquo;\t\n&amp;rdquo;,Linux下为&amp;rdquo;\n&amp;rdquo;
 os.pathsep
输出用于分割文件路径的字符串 win下为; , Linux下为:
 os.name
输出字符串指示当前使用平台。win-&amp;gt;&amp;lsquo;nt&amp;rsquo;; Linux-&amp;gt;&amp;lsquo;posix&amp;rsquo;
 os.system(&amp;ldquo;bash command&amp;rdquo;)
运行shell命令，直接显示
 os.environ
获取系统环境变量</description>
    </item>
    
    <item>
      <title>Python基础3</title>
      <link>/blog/python/python%E5%9F%BA%E7%A1%803/</link>
      <pubDate>Mon, 25 May 2020 00:34:18 +0800</pubDate>
      
      <guid>/blog/python/python%E5%9F%BA%E7%A1%803/</guid>
      <description> </description>
    </item>
    
    <item>
      <title>Python基础2</title>
      <link>/blog/python/python%E5%9F%BA%E7%A1%802/</link>
      <pubDate>Mon, 25 May 2020 00:09:04 +0800</pubDate>
      
      <guid>/blog/python/python%E5%9F%BA%E7%A1%802/</guid>
      <description>字符串 定义my_str为一个字符串
   方法 格式 功能     [] my_str[起始下标:结束:步长] 切片是指对操作的对象截取其中一部分的操作   find() my_str.find(str, start=0, end=len(mystr)) 检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则返回-1   rfind() my_str.rfind(str, start=0,end=len(mystr) ) 类似于 find()函数，不过是从右边开始查找.   index() my_str.index(str, start=0, end=len(mystr)) 检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则报错   count() my_str.count(str, start=0, end=len(mystr)) 返回 str在start和end之间 在 mystr里面出现的次数   replace() my_str.replace(str1, str2, mystr.count(str1)) 把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次.   split() my_str.</description>
    </item>
    
    <item>
      <title>Python基础1</title>
      <link>/blog/python/python%E5%9F%BA%E7%A1%801/</link>
      <pubDate>Sun, 24 May 2020 22:55:15 +0800</pubDate>
      
      <guid>/blog/python/python%E5%9F%BA%E7%A1%801/</guid>
      <description>注释 注释的作用：解释当前代码的作用或用途 （1. 给自己看；2. 给同事看；3. 服务于自己调试代码（注释的代码是不会执行的！）） Python中的注释有单行注释和多行注释： Python中单行注释以 # 开头（快捷键为：Ctrl + /）
python中的多行注释 多行注释用三个单引号 &#39;&amp;rsquo;&amp;rsquo; 或者三个双引号 &amp;quot;&amp;rdquo;&amp;rdquo; 将注释括起来。
格式化输出 str=&amp;quot;网站名称：{:&amp;gt;9s}\t网址：{:s}&amp;quot; print(str.format(&amp;quot;C语言中文网&amp;quot;,&amp;quot;c.biancheng.net&amp;quot;)) #以货币形式显示 print(&amp;quot;货币形式：{:,d}&amp;quot;.format(1000000)) #科学计数法表示 print(&amp;quot;科学计数法：{:E}&amp;quot;.format(1200.12)) #以十六进制表示 print(&amp;quot;100的十六进制：{:#x}&amp;quot;.format(100)) #输出百分比形式 print(&amp;quot;0.01的百分比表示：{:.0%}&amp;quot;.format(0.01))  输入 python2.x中的输入是这样的：raw_input() python3.x中的输入是这样的：input()  运算符 算术运算符：
赋值运算符：=
数据类型的转换
比较运算符：
逻辑运算符：
if 条件句 if a: pass elif: pass if b: pass else: pass else: pass  while循环 while i &amp;lt; 10: pass i += 1 # 无限循环 while True: pass # 或 while 1: pass  while True 和while 1的区别</description>
    </item>
    
    <item>
      <title>Redis优化</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sun, 24 May 2020 22:45:47 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E4%BC%98%E5%8C%96/</guid>
      <description>redis优化
数据持久化 Redis提供了将数据定期自动持久化至硬盘的能力，包括RDB和AOF两种方案，两种方案分别有其长处和短板，可以配合起来同时运行，确保数据的稳定性。
必须使用数据持久化吗？ Redis的数据持久化机制是可以关闭的。如果你只把Redis作为缓存服务使用，Redis中存储的所有数据都不是该数据的主体而仅仅是同步过来的备份，那么可以关闭Redis的数据持久化机制。 但通常来说，仍然建议至少开启RDB方式的数据持久化，因为：
 RDB方式的持久化几乎不损耗Redis本身的性能，在进行RDB持久化时，Redis主进程唯一需要做的事情就是fork出一个子进程，所有持久化工作都由子进程完成 Redis无论因为什么原因crash掉之后，重启时能够自动恢复到上一次RDB快照中记录的数据。这省去了手工从其他数据源（如DB）同步数据的过程，而且要比其他任何的数据恢复方式都要快 现在硬盘那么大，真的不缺那一点地方  RDB 采用RDB持久方式，Redis会定期保存数据快照至一个rbd文件中，并在启动时自动加载rdb文件，恢复之前保存的数据。可以在配置文件中配置Redis进行快照保存的时机：
save [seconds] [changes]`意为在[seconds]秒内如果发生了[changes]次数据修改，则进行一次RDB快照保存，例如
会让Redis每60秒检查一次数据变更情况，如果发生了100次或以上的数据变更，则进行RDB快照保存。 可以配置多条save指令，让Redis执行多级的快照保存策略。 Redis默认开启RDB快照，默认的RDB策略如下：
也可以通过BGSAVE命令手工触发RDB快照保存。
RDB的优点：
 对性能影响最小。如前文所述，Redis在保存RDB快照时会fork出子进程进行，几乎不影响Redis处理客户端请求的效率。 每次快照会生成一个完整的数据快照文件，所以可以辅以其他手段保存多个时间点的快照（例如把每天0点的快照备份至其他存储媒介中），作为非常可靠的灾难恢复手段。 使用RDB文件进行数据恢复比使用AOF要快很多。  RDB的缺点：
 快照是定期生成的，所以在Redis crash时或多或少会丢失一部分数据。 如果数据集非常大且CPU不够强（比如单核CPU），Redis在fork子进程时可能会消耗相对较长的时间（长至1秒），影响这期间的客户端请求。  AOF 采用AOF持久方式时，Redis会把每一个写请求都记录在一个日志文件里。在Redis重启时，会把AOF文件中记录的所有写操作顺序执行一遍，确保数据恢复到最新。
AOF默认是关闭的，如要开启，进行如下配置：
AOF提供了三种fsync配置，always/everysec/no，通过配置项[appendfsync]指定：
 appendfsync no：不进行fsync，将flush文件的时机交给OS决定，速度最快 appendfsync always：每写入一条日志就进行一次fsync操作，数据安全性最高，但速度最慢 appendfsync everysec：折中的做法，交由后台线程每秒fsync一次  随着AOF不断地记录写操作日志，必定会出现一些无用的日志，例如某个时间点执行了命令SET key1 &amp;ldquo;abc&amp;rdquo;，在之后某个时间点又执行了SET key1 &amp;ldquo;bcd&amp;rdquo;，那么第一条命令很显然是没有用的。大量的无用日志会让AOF文件过大，也会让数据恢复的时间过长。 所以Redis提供了AOF rewrite功能，可以重写AOF文件，只保留能够把数据恢复到最新状态的最小写操作集。 AOF rewrite可以通过BGREWRITEAOF命令触发，也可以配置Redis定期自动进行：
上面两行配置的含义是，Redis在每次AOF rewrite时，会记录完成rewrite后的AOF日志大小，当AOF日志大小在该基础上增长了100%后，自动进行AOF rewrite。同时如果增长的大小没有达到64mb，则不会进行rewrite。
AOF的优点：
 最安全，在启用appendfsync always时，任何已写入的数据都不会丢失，使用在启用appendfsync everysec也至多只会丢失1秒的数据。 AOF文件在发生断电等问题时也不会损坏，即使出现了某条日志只写入了一半的情况，也可以使用redis-check-aof工具轻松修复。 AOF文件易读，可修改，在进行了某些错误的数据清除操作后，只要AOF文件没有rewrite，就可以把AOF文件备份出来，把错误的命令删除，然后恢复数据。  AOF的缺点：
 AOF文件通常比RDB文件更大 性能消耗比RDB高 数据恢复速度比RDB慢  内存管理与数据淘汰机制 最大内存设置 默认情况下，在32位OS中，Redis最大使用3GB的内存，在64位OS中则没有限制。</description>
    </item>
    
    <item>
      <title>Django的RBAC管理模型</title>
      <link>/blog/django/13-django%E7%9A%84rbac%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Thu, 21 May 2020 13:56:48 +0800</pubDate>
      
      <guid>/blog/django/13-django%E7%9A%84rbac%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B/</guid>
      <description>RBAC框架 from django.db import models # 时间模块快 from django.utils import timezone # 用户表 from django.contrib.auth.models import AbstractUser # Create your models here. # 基类表 class Base(models.Model): create_time = models.DateTimeField(default=timezone.now, null=True) # 添加数据时，自动写入当前添加时间 is_delete = models.IntegerField(default=0) # 逻辑关联删除字段({0:未删除,1:已删除}) class Meta: abstract = True # 用户 # 用户和角色是多对多 class User(AbstractUser): username = models.CharField(max_length=200, unique=True) # 用户名 password = models.CharField(max_length=200) # 密码 phone = models.CharField(max_length=11) # 手机号 photo = models.CharField(max_length=200, default=&amp;quot;1.jpg&amp;quot;) # 头像 oid = models.</description>
    </item>
    
    <item>
      <title>Django与MySql物理外键</title>
      <link>/blog/django/12-django%E4%B8%8Emysql%E7%89%A9%E7%90%86%E5%A4%96%E9%94%AE/</link>
      <pubDate>Thu, 21 May 2020 12:45:14 +0800</pubDate>
      
      <guid>/blog/django/12-django%E4%B8%8Emysql%E7%89%A9%E7%90%86%E5%A4%96%E9%94%AE/</guid>
      <description>一套常用的、最不容易出bug的外键操作逻辑 创建外键 创建一个外键，使用models.ForeignKey()字段。 字段名为对象名，而非id，比如office 在创建外键后，这个office在数据库中的字段名体现为office_id
它会在数据库中表现为int类型，在django查询时自动转化为目标对象
class User(AbstractUser): username = models.CharField(max_length=200, unique=True) # 用户名 password = models.CharField(max_length=200) # 密码 phone = models.CharField(max_length=11) # 手机号 photo = models.CharField(max_length=200, default=&amp;quot;1.jpg&amp;quot;) # 头像 # 外键字段 office = models.ForeignKey(&#39;Office&#39;, on_delete=models.SET_NULL, null=True) # 公司id is_delete = models.IntegerField(default=0) # 逻辑删除 # on_delete的用法： on_delete=None, # 删除关联表中的数据时,当前表与其关联的field的行为 on_delete=models.CASCADE, # 删除关联数据,与之关联也删除 on_delete=models.DO_NOTHING, # 删除关联数据,什么也不做 on_delete=models.PROTECT, # 删除关联数据,引发错误ProtectedError # models.ForeignKey(&#39;关联表&#39;, on_delete=models.SET_NULL, blank=True, null=True) on_delete=models.SET_NULL, # 删除关联数据,与之关联的值设置为null（前提FK字段需要设置为可空,一对一同理） # models.ForeignKey(&#39;关联表&#39;, on_delete=models.SET_DEFAULT, default=&#39;默认值&#39;) on_delete=models.</description>
    </item>
    
    <item>
      <title>Vue中的高德地图</title>
      <link>/blog/vue/01-vue%E4%B8%AD%E7%9A%84%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/</link>
      <pubDate>Wed, 20 May 2020 00:24:53 +0800</pubDate>
      
      <guid>/blog/vue/01-vue%E4%B8%AD%E7%9A%84%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/</guid>
      <description>vue中高德地图的使用 1. 准备工作 vue搭建 高德开发key值申请（链接：高德开放平台），key值请放入以下需要对号入座的地方 地图样式挑选，需要申请到key值后，在高德开放平台自动移地图模板处挑选配置。此处用 极夜蓝模板来示例，也可选择其他模板。然后发布=&amp;gt;复制与分享=&amp;gt;辅助出来样式ID。如： bb7f5165253f57515d7ba226b2******，然后放入以下需要对号入座的地方 注：第二步和第三步申请的两个值需要对应使用
2. 地图引入项目 入口文件index.html引入标签:
&amp;lt;script src=&amp;quot;https://webapi.amap.com/maps?v=1.4.15&amp;amp;key=这里放入key值&amp;quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script src=&amp;quot;//webapi.amap.com/ui/1.0/main.js?v=1.0.11&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;  vue.config.js中配置:
module.exports = { // ... configureWebpack(config) { // ... config.externals = { &#39;AMap&#39;: &#39;AMap&#39; // 高德地图配置 } } }  使用该功能的组件中引入：
import AMap from &amp;quot;AMap&amp;quot;  3. 使用
地图初始化即可：
&amp;lt;div class=&amp;quot;map&amp;quot; id=&amp;quot;map&amp;quot;&amp;gt; // 引入地图组件 import AMap from &amp;quot;AMap&amp;quot; // 初始化 MapInit () { let _this = this; let map = new AMap.</description>
    </item>
    
    <item>
      <title>Django中的联合索引</title>
      <link>/blog/django/11-django%E4%B8%AD%E7%9A%84%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/</link>
      <pubDate>Tue, 19 May 2020 23:19:52 +0800</pubDate>
      
      <guid>/blog/django/11-django%E4%B8%AD%E7%9A%84%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/</guid>
      <description>Mysql中的联合唯一索引 有这样一张表，它要记录一个人的浏览记录。
   id uid gid     1 1 1   2 1 2   3 1 3   4 2 1   5 2 3   6 2 5    每个人的浏览记录只记一次，每个人可以浏览多个商品，每个商品也可以被多个人浏览。
但是每条记录是单一的，不可重复。比如id为1的这条记录，{uid:1}可重复，{cid:1}可重复，但{uid:1, cid:1}，它只能出现一次。
这中情况，我们需要联合唯一索引来限制。
建立联合唯一索引：从Navicat建立：
表名称为：table_a
两个字段分别为：key_a key_b
执行语句：
alter table table_a add unique index(key_a,key_b);
建立了联合索引之后，表中不能插入两个字段值同时相等的数据。
Django中实现联合唯一索引 class UserOrderHouse(models.Model): &amp;quot;&amp;quot;&amp;quot; 客户预约表 &amp;quot;&amp;quot;&amp;quot; broker_id = models.ForeignKey(to=&amp;quot;Broker&amp;quot;, verbose_name=&amp;quot;经纪人&amp;quot;, null=True, blank=True) client_id = models.</description>
    </item>
    
    <item>
      <title>RBAC权限管理模型理念</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/rbac%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B%E7%90%86%E5%BF%B5/</link>
      <pubDate>Mon, 18 May 2020 18:08:10 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/rbac%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B%E7%90%86%E5%BF%B5/</guid>
      <description> RBAC权限管理模型：基本模型及角色模型解析及举例 概念 RBAC是一套成熟的权限模型。在传统权限模型中，我们直接把权限赋予用户。而在RBAC中，增加了“角色”的概念，我们首先把权限赋予角色，再把角色赋予用户。这样，由于增加了角色，授权会更加灵活方便。在RBAC中，根据权限的复杂程度，又可分为RBAC0、RBAC1、RBAC2、RBAC3。其中，RBAC0是基础，RBAC1、RBAC2、RBAC3都是以RBAC0为基础的升级。用户和角色，角色和权限都是多对多的关系。用户拥有的权限等于他所有的角色持有权限之和。
RBAC1建立在RBAC0基础之上，在角色中引入了继承的概念。
RBAC2同样建立在RBAC0基础之上，仅是对用户、角色和权限三者之间增加了一些限制。这些限制可以分成两类，即静态职责分离SSD(Static Separation of Duty)和动态职责分离DSD(Dynamic Separation of Duty)。
譬如给一个用户分配了销售经理的角色，就不能给他再赋予财务经理的角色了，否则他即可以录入合同又能自己审核合同；再譬如，有些公司对角色的升级十分看重，一个销售员要想升级到销售经理，必须先升级到销售主管，这时候就要采用先决条件限制了。
RBAC3是RBAC1和RBAC2的合集，所以RBAC3既有角色分层，也包括可以增加各种限制。
基于RBAC模型，还可以适当延展，使其更适合我们的产品。譬如增加用户组概念，直接给用户组分配角色，再把用户加入用户组。这样用户除了拥有自身的权限外，还拥有了所属用户组的所有权限。
应用 </description>
    </item>
    
    <item>
      <title>Django中的jwt</title>
      <link>/blog/django/10-django%E4%B8%AD%E7%9A%84jwt/</link>
      <pubDate>Mon, 27 Apr 2020 08:16:32 +0800</pubDate>
      
      <guid>/blog/django/10-django%E4%B8%AD%E7%9A%84jwt/</guid>
      <description>JWT概念   组成: header.payload.signature 头.载荷.签名
  举例：
 eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoxLCJ1c2VybmFtZSI6Im93ZW4iLCJleHAiOjE1NTgzMDM1NDR9.4j5QypLwufjpqoScwUB9LYiuhYcTw1y4dPrvnv7DUyo    介绍： header：一般存放如何处理token的方式：加密的算法、是否有签名等 payload：数据的主体部分：用户信息、发行者、过期时间等 signature：签名：将header、payload再结合密码盐整体处理一下
  工作原理  jwt = base64(头部).base64(载荷).hash256(base64(头部).base(载荷).密钥) base64是可逆的算法、hash256是不可逆的算法 密钥是固定的字符串，保存在服务器  drf-jwt [官方文档]https://github.com/jpadilla/django-rest-framework-jwt
安装子虚拟环境 pip install djangorestframework-jwt  使用：user/urls.py from django.urls import path from rest_framework_jwt.views import obtain_jwt_token urlpatterns = [ path(&#39;login/&#39;, obtain_jwt_token), ]  测试接口：post请求 postman发生post请求
接口：http://api.luffy.cn:8000/user/login/ 数据： { &amp;quot;username&amp;quot;:&amp;quot;admin&amp;quot;, &amp;quot;password&amp;quot;:&amp;quot;admin&amp;quot; }  drf-jwt开发 配置信息：JWT_AUTH到dev.py中 import datetime JWT_AUTH = { # 过期时间 &#39;JWT_EXPIRATION_DELTA&#39;: datetime.</description>
    </item>
    
    <item>
      <title>Vue封装axios</title>
      <link>/blog/vue/02-vue%E5%B0%81%E8%A3%85axios/</link>
      <pubDate>Tue, 21 Apr 2020 09:41:28 +0800</pubDate>
      
      <guid>/blog/vue/02-vue%E5%B0%81%E8%A3%85axios/</guid>
      <description>作用 封装请求的方式有多种多样，目的是便于管理vue项目中axios请求的路由。
步骤 https://www.cnblogs.com/ppzhang/p/12502019.html
# 创建文件 components/axios_api/http.js # 导入axios import axios from &#39;axios&#39;  封装：@/axios_api/http.js import axios from &#39;axios&#39; axios.defaults.baseURL=&amp;quot;http://127.0.0.1:8000/&amp;quot; axios.defaults.timeout = 1000000; axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/json&#39;; axios.defaults.headers.put[&#39;Content-Type&#39;] = &#39;application/json&#39;; axios.interceptors.request.use( config =&amp;gt; { // 每次发送请求之前判断是否存在token，如果存在，则统一在http请求的header都加上token，不用每次请求都手动添加了 const token = sessionStorage.getItem(&amp;quot;jwt_token&amp;quot;) console.log(token) if (token){ // 将token保存到头部信息的&#39;Authorization&#39;字段中，每次发起请求自动传入后端 config.headers.Authorization = token } return config; }, error =&amp;gt; { return Promise.error(error); }) axios.interceptors.response.use( // 请求成功 res =&amp;gt; res.status === 200 ? Promise.resolve(res) : Promise.reject(res), // 请求失败 error =&amp;gt; { if (error.</description>
    </item>
    
    <item>
      <title>Git多人项目</title>
      <link>/blog/git/04-git%E5%A4%9A%E4%BA%BA%E9%A1%B9%E7%9B%AE/</link>
      <pubDate>Tue, 21 Apr 2020 08:44:02 +0800</pubDate>
      
      <guid>/blog/git/04-git%E5%A4%9A%E4%BA%BA%E9%A1%B9%E7%9B%AE/</guid>
      <description>线上  master - 主分支，提交已经通过测试的代码 develop - 测试环境，服务器环境 管理分支 - 可以新建分支，为程序员创建个人分支  本地   每个人在本地创建个人分支
 mkdir xx git init git clone &amp;quot;master的ssh&amp;quot; # 进行代码更新操作 # 创建分支 git branch develop origin/develop git branch xx origin/xx # 查看分支 git branch # 切换节点 git checkout xx # 整合到测试环境 git add -A git commit -m &amp;quot;&amp;quot; git push origin xx # 切换 git checkout develop # 整合 git merge xx    向分支上推送代码：</description>
    </item>
    
    <item>
      <title>Django文件传输</title>
      <link>/blog/django/09-django%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</link>
      <pubDate>Wed, 15 Apr 2020 20:27:01 +0800</pubDate>
      
      <guid>/blog/django/09-django%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93/</guid>
      <description>前端
 &amp;lt;template&amp;gt; &amp;lt;!-- 展示当前头像 --&amp;gt; &amp;lt;div id = &#39;photo_img&#39;&amp;gt; &amp;lt;center&amp;gt; &amp;lt;Avatar :src=&amp;quot;photo&amp;quot; :width=&#39;width&#39; fit=&#39;fill&#39;&amp;gt;&amp;lt;/Avatar&amp;gt; &amp;lt;/center&amp;gt; &amp;lt;!-- &amp;lt;img :src=&amp;quot;photo&amp;quot; alt=&amp;quot;&amp;quot; width=100% height=100%&amp;gt; --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;form action=&amp;quot;&amp;quot;&amp;gt; &amp;lt;!-- 前端上传头像 --&amp;gt; &amp;lt;input type=&amp;quot;file&amp;quot; @change=&#39;change($event)&#39;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/template&amp;gt; &amp;lt;script&amp;gt; import { config } from &#39;../config&#39;; export default { data:(){ photo:&#39;&#39; } methods:{ change:function(event){ console.log(event.target.files) var data = new FormData() data.append(&#39;file&#39;,event.target.files[0]) this.axios.post(&#39;/api/upload_file/&#39;,data,{headers: {&#39;Content-Type&#39;: &#39;multipart/form-data&#39;}}).then(resp=&amp;gt;{ this.photo = config.baseurl + &#39;/static/upload/&#39; +resp.data.data }) }, } } &amp;lt;/script&amp;gt;    后端</description>
    </item>
    
    <item>
      <title>Django反序列化</title>
      <link>/blog/django/08-django%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</link>
      <pubDate>Wed, 15 Apr 2020 20:20:20 +0800</pubDate>
      
      <guid>/blog/django/08-django%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</guid>
      <description> 反序列化可以节省代码量
  后端
 class InsertData(APIView): def post(self, request): res = {} data = DataSer(data= request.data) if data.isvalid(): data.save() res[&#39;code&#39;] = 200 return Response(res) # 配置数据库、序列化器、路由省略，导包省略    前端
 send_data(){ this.axios.post(config.baseurl + &#39;/insert_data/&#39;, this.qs.stringify({ key1: value1, key2: value2, key3: value3, })).then(resp =&amp;gt; { console.log(resp.data.data) }) },   </description>
    </item>
    
    <item>
      <title>JS正则表达式</title>
      <link>/blog/javascript/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Wed, 15 Apr 2020 19:56:37 +0800</pubDate>
      
      <guid>/blog/javascript/js%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>正则表达式 英语：Regular Expression，在代码中常简写为regex、regexp或RE，使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。
 语法 /正则表达式主体/修饰符(可选)
var patt = /runoob/i
 /runoob/i 是一个正则表达式。
runoob 是一个正则表达式主体 (用于检索)。
i 是一个修饰符 (搜索不区分大小写)。
  test() 和 exec() JS 判断输入是否为数字、字母、下划线组成
/^\w+$/.test(str) # 结果为布尔类型
输出匹配到的结果
/www/.exec(&#39;www&#39;) # 结果为数组 [&amp;quot;www&amp;quot;]
封装
function isValid(str) { return /^\w+$/.test(str); } # 返回布尔值
正则表达式修饰符 /Www/i.test(&#39;www&#39;) --&amp;gt; true
   修饰符 描述     i 大小写不敏感   g 全局匹配，而非找到第一个匹配后停止   m 执行多行匹配    正则表达式模式    表达式 描述     [abc] 查找方括号内的任意字符   [0-9] 查找0-9之间的数字   （x|y) 查找任何以|分隔的选项       元字符 描述     \d 查找数字   \s 查找空白字符   \b 匹配单词边界   \uxxxx 查找以十六进制数 xxxx 规定的 Unicode 字符       量词 描述     n+ 匹配任何包含至少一个n的字符串   n* 匹配任何包含0或多个n的字符串   n?</description>
    </item>
    
    <item>
      <title>Linux常用命令</title>
      <link>/blog/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sun, 12 Apr 2020 23:20:21 +0800</pubDate>
      
      <guid>/blog/linux/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>系统命令 runlevel # 查看当前的运行级别 systemctl status firewalld # 开启网络服务功能 stop # 关闭 restart # 重启 reload # 重载 reboot # 重启 halt # 关机 poweroff # 关机  查看文件常用指令 cat # 在命令提示符下查看文件内容 more # 在命令提示符中分页查看文件内容 less # 命令行中查看文件可以上下翻页反复浏览 head # 命令行中查看文件头几行 tail # 命令行中查看文件尾几行 wc # 统计文件的单词数 行数等信息  目录管理常用指令 pwd # 查看你当前所在的目录 cd # 切换目录 ls # 查看显示目录的内容 du # 统计目录和文件空间的占用情况 mkdir # 创建新目录 rmdir # 删除空目录 touch # 创建文件 rm # 删除文件 ln # 创建硬链接 ln -s # 创建软链接 cp # 复制文件或目录 mv # 移动文件或目录 which # 查看linux命令所在的目录  账号与权限 &#39;&#39;&#39;1.</description>
    </item>
    
    <item>
      <title>Linux Supervisor</title>
      <link>/blog/linux/linux-supervisor/</link>
      <pubDate>Sun, 12 Apr 2020 23:19:00 +0800</pubDate>
      
      <guid>/blog/linux/linux-supervisor/</guid>
      <description> 场景需求 我司运营部门日常工作需要处理大量数据和报表，我司拟开发内部OA系统提高各部门工作效率。现项目内设备扫描功能使用了celery做的任务队列，进行异步扫描，同时又使用到Flower来监控任务队列。为了方便管理，在项目中使用了Supervisor来管理进程数据。请实现使用supervisor进行任务管理
参考答案 Supervisor是用Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统。它可以很方便的监听、启动、停止、重启一个或多个进程。用Supervisor管理的进程，当一个进程意外被杀死，supervisort监听到进程死后，会自动将它重新拉起，很方便的做到进程自动恢复的功能，不再需要自己写shell脚本来控制。
不使用守护进程会出现的三个问题：  ASP.NET Core应用程序运行在shell之中，如果关闭shell则会发现 ASP.NET Core程序被关闭，从而导致应用无法访问，这种情况当然是我们不想遇到的，而且生产环境对这种情况是零容忍的。 如果 ASP.NET Core进程意外终止那么需要人为连进shell进行再次启动，往往这种操作都不够及时。 如果服务器宕机或需要重启，我们则还是需要连入shell进行启动。  为了解决这些问题，我们需要有一个程序来监听 ASP.NET Core 应用程序的状况。并在应用程序停止运行的时候立即重新启动
# 编辑进程管理配置文件 [root@sandboxmp ~]$ touch /etc/supervisord.d/celery_worker.ini [root@sandboxmp ~]$ vim /etc/supervisord.d/celery_worker.ini # 将以下内容写入配置文件保存并退出 [program:celery-worker] command=/root/.virtualenvs/sandboxMP/bin/celery worker -A sandboxMP -l INFO directory=/opt/app/sandboxMP environment=PATH=&amp;quot;/root/.virtualenvs/sandboxMP/bin/&amp;quot; stdout_logfile=/opt/app/sandboxMP/slogs/celery_worker.log stderr_logfile=/opt/app/sandboxMP/slogs/celery_worker.log autostart=true autorestart=true priority=901 [program:celery-flower] command=/root/.virtualenvs/sandboxMP/bin/celery flower --broker=redis://localhost:6379/0 directory=/opt/app/sandboxMP environment=PATH=&amp;quot;/root/.virtualenvs/sandboxMP/bin/&amp;quot; stdout_logfile=/opt/app/sandboxMP/slogs/celery_flower.log stderr_logfile=/opt/app/sandboxMP/slogs/celery_flower.log autostart=true autorestart=true priority=900 systemctl start supervisord # 启动supervisord systemctl enable supervisord # 加到开机启动 </description>
    </item>
    
    <item>
      <title>青蛙跳台阶</title>
      <link>/blog/python/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/</link>
      <pubDate>Sun, 12 Apr 2020 23:18:12 +0800</pubDate>
      
      <guid>/blog/python/%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6/</guid>
      <description> 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。
fib = lambda n: n if n &amp;lt; 2 else 2 * fib(n - 1) </description>
    </item>
    
    <item>
      <title>递归斐波那契</title>
      <link>/blog/python/%E9%80%92%E5%BD%92%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/</link>
      <pubDate>Sun, 12 Apr 2020 23:17:57 +0800</pubDate>
      
      <guid>/blog/python/%E9%80%92%E5%BD%92%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91/</guid>
      <description> def fun(i): if i == 0: return 0 elif i == 1: return 1 else: return fun(i-2) + fei(i-1) if __name__ == &#39;__main__&#39;: for i in range(10): print(fun(i),end=&amp;quot; &amp;quot;) </description>
    </item>
    
    <item>
      <title>快排</title>
      <link>/blog/python/%E5%BF%AB%E6%8E%92/</link>
      <pubDate>Sun, 12 Apr 2020 23:15:51 +0800</pubDate>
      
      <guid>/blog/python/%E5%BF%AB%E6%8E%92/</guid>
      <description> 快排代码实现（类似于二叉树 递归调用）&amp;mdash;-右手左手一个慢动作，右手左手一个慢动作重播
#! /usr/bin/env python # -*- coding: utf-8 -*- def quick(list): if len(list) &amp;lt; 2: return list tmp = list[0] # 临时变量 可以取随机值 left = [x for x in list[1:] if x &amp;lt;= tmp] # 左列表 right = [x for x in list[1:] if x &amp;gt; tmp] # 右列表 return quick(left) + [tmp] + quick(right) li = [4,3,7,5,8,2] print quick(li) # [2, 3, 4, 5, 7, 8] #### 对[4,3,7,5,8,2]排序 &#39;&#39;&#39; [3, 2] + [4] + [7, 5, 8] # tmp = [4] [2] + [3] + [4] + [7, 5, 8] # tmp = [3] 此时对[3, 2]这个列表进行排序 [2] + [3] + [4] + [5] + [7] + [8] # tmp = [7] 此时对[7, 5, 8]这个列表进行排序 &#39;&#39;&#39; </description>
    </item>
    
    <item>
      <title>冒泡法排序</title>
      <link>/blog/python/%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sun, 12 Apr 2020 23:15:22 +0800</pubDate>
      
      <guid>/blog/python/%E5%86%92%E6%B3%A1%E6%B3%95%E6%8E%92%E5%BA%8F/</guid>
      <description> 原理：拿自己与上面一个比较，如果上面一个比自己小就将自己和上面一个调换位置，依次再与上面一个比较，第一轮结束后最上面那个一定是最大的数
#! /usr/bin/env pythonf # -*- coding: utf-8 -*- def bubble_sort(li): for i in range(len(li)-1): for j in range(len(li)-i-1): if li[j] &amp;gt; li[j+1]: li[j],li[j+1]=li[j+1],li[j] li = [1,5,2,6,3,7,4,8,9,0] bubble_sort(li) print(li) # [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] </description>
    </item>
    
    <item>
      <title>二分法查找</title>
      <link>/blog/python/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/</link>
      <pubDate>Sun, 12 Apr 2020 23:15:04 +0800</pubDate>
      
      <guid>/blog/python/%E4%BA%8C%E5%88%86%E6%B3%95%E6%9F%A5%E6%89%BE/</guid>
      <description> l = list(range(1,101)) def bin_search(data_set,val): low = 0 high = len(data_set) - 1 while low &amp;lt;= high: mid = (low+high)//2 if data_set[mid] == val: return mid elif data_set[mid] &amp;lt; val: low = mid + 1 else: high = mid - 1 return n = bin_search(l,11) print(n) # 返回结果是： 10 </description>
    </item>
    
    <item>
      <title>常见数据结构</title>
      <link>/blog/python/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sun, 12 Apr 2020 23:10:26 +0800</pubDate>
      
      <guid>/blog/python/%E5%B8%B8%E8%A7%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description> 栈  栈的定义：栈是一种数据集合，可以理解为只能在一端进行插入或删除操作的列表 栈的特点：后进先出（last-in, first-out）  队列  队列是一个数据集合，仅允许在列表的一端进行插入，另一端进行删除 插入的一端称为队尾（rear），插入动作叫进队或入队 进行删除的一端称为对头（front），删除动作称为出队 队列性质：先进先出（First-in, First-out） 双向队列：队列的两端都允许进行进队和出队操作  链表 链表中每个元素都是一个对象，每个对象称为一个节点，包含有数据域key和指向下一节点的指针next，通过各个节点间的相互连接，最终串联成一个链表
数组  所谓数组，就是相同数据类型的元素按一定顺序排列的集合 在Java等其他语言中并不是所有的数据都能存储到数组中，只有相同类型的数据才可以一起存储到数组中。 因为数组在存储数据时是按顺序存储的，存储数据的内存也是连续的，所以他的特点就是寻址读取数据比较容易，插入和删除比较困难  字典对象实现原理  哈希表 (hash tables)
 哈希表（也叫散列表），根据关键值对(Key-value)而直接进行访问的数据结构。
它通过把key和value映射到表中一个位置来访问记录，这种查询速度非常快，更新也快。
而这个映射函数叫做哈希函数，存放值的数组叫做哈希表。
通过把每个对象的关键字k作为自变量，通过一个哈希函数h(k)，将k映射到下标h(k)处，并将此对象存储在这个位置。
 具体操作过程
 数据添加：把key通过哈希函数转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将value存储在以该数字为下标的数组空间里。
数据查询：再次使用哈希函数将key转换为对应的数组下标，并定位到数组的位置获取value。
 {“name”:”zhangsan”,”age”:26} 字典如何存储的呢?
 比如字典{“name”:”zhangsan”,”age”:26}，那么他们的字典key为name、age，假如哈希函数h(“name”) = 1、h(“age”)=3,
那么对应字典的key就会存储在列表对应下标的位置，[None, “zhangsan”, None, 26
 解决hash冲突
 </description>
    </item>
    
    <item>
      <title>Redis Codis集群</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis-codis%E9%9B%86%E7%BE%A4/</link>
      <pubDate>Sun, 12 Apr 2020 23:07:13 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis-codis%E9%9B%86%E7%BE%A4/</guid>
      <description> 为什么会出现codis  在大数据高并发场景下，单个redis实例往往会无法应对 首先redis内存不易过大，内存太大会导致rdb文件过大，导致主从同步时间过长 其次在CPU利用率中上，单个redis实例只能利用单核，数据量太大，压力就会特别大  什么是codis  codis是redis集群解决方案之一，codis是GO语言开发的代理中间件 当客户端向codis发送指令时，codis负责将指令转发给后面的redis实例来执行，并将返回结果转发给客户端  codis部署方案  单个codis代理支撑的QPS比较有限，通过启动多个codis代理可以显著增加整体QPS 多codis还能起到容灾功能，挂掉一个codis代理还有很多codis代理可以继续服务  codis分片的原理  codis负责将特定key转发到特定redis实例，codis默认将所有key划分为1024个槽位 首先会对客户端传来的key进行crc32计算hash值，然后将hash后的整数值对1024进行取模，这个余数就是对应的key槽位 每个槽位都会唯一映射到后面的多个redis实例之一，codis会在内存中维护槽位和redis实例的映射关系 这样有了上面key对应的槽位，那么它应该转发到那个redis实例就很明确了 槽位数量默认是1024，如果集群中节点较多，建议将这个数值大一些，比如2048,4096  不同codis槽位如何同步  如果codis槽位值存在内存中，那么不同的codis实例间的槽位关系得不到同步 所以codis还需要一个分布式配置存储的数据库专门来持久化槽位关系 codis将槽位关系存储在zookeeper中，并且提供一个dashboard可以来观察和修改槽位关系  进入从库发现6380之前的角色是slave，现在已经是master了。也就是成功了。  </description>
    </item>
    
    <item>
      <title>Redis哨兵模式    Sentinel</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F-sentinel/</link>
      <pubDate>Sun, 12 Apr 2020 23:04:21 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F-sentinel/</guid>
      <description>sentinel作用  当用Redis做主从方案时，假如master宕机，Redis本身无法自动进行主备切换 而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。  sentinel原理  sentinel负责持续监控主节点的健康，当主节挂掉时，自动选择一个最优的从节点切换成主节点 从节点来连接集群时会首先连接sentinel，通过sentinel来查询主节点的地址 当主节点发生故障时，sentinel会将最新的主节点地址告诉客户端，可以实现无需重启自动切换redis  Sentinel支持集群  只使用单个sentinel进程来监控redis集群是不可靠的，当sentinel进程宕掉后sentinel本身也有单点问题 如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于redis集群中的信息。  Sentinel版本  Sentinel当前稳定版本称为Sentinel 2，Redis2.8和Redis3.0附带稳定的哨兵版本 安装完redis-3.2.8后，redis-3.2.8/src/redis-sentinel启动程序 redis-3.2.8/sentinel.conf是配置文件。  运行sentinel两种方式（效果相同） 法1：redis-sentinel /path/to/sentinel.conf
法2：redis-server /path/to/sentinel.conf --sentinel
 以上两种方式，都必须指定一个sentinel的配置文件sentinel.conf，如果不指定，将无法启动sentinel。 sentinel默认监听26379端口，所以运行前必须确定该端口没有被别的进程占用。  sentinel.conf配置文件说明   配置文件只需要配置master的信息就好啦，不用配置slave的信息，因为slave能够被自动检测到
  需要注意的是，配置文件在sentinel运行期间是会被动态修改的，例如当发生主备切换时候，配置文件中的master会被修改为另外一个slave。
  这样，之后sentinel如果重启时，就可以根据这个配置来恢复其之前所监控的redis集群的状态。
 # sentinel.conf 配置说明 sentinel monitor mymaster 127.0.0.1 6379 2 sentinel down-after-milliseconds mymaster 60000 sentinel failover-timeout mymaster 180000 sentinel parallel-syncs mymaster 1    配置传播  一旦一个sentinel成功地对一个master进行了failover，它将会把关于master的最新配置通过广播形式通知其它sentinel，其它的sentinel则更新对应master的配置。 一个faiover要想被成功实行，sentinel必须能够向选为master的slave发送SLAVE OF NO ONE命令，然后能够通过INFO命令看到新master的配置信息。 当将一个slave选举为master并发送SLAVE OF NO ONE`后，即使其它的slave还没针对新master重新配置自己，failover也被认为是成功了的。  因为每一个配置都有一个版本号，所以以版本号最大的那个为标准：</description>
    </item>
    
    <item>
      <title>Redis主从同步</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Sun, 12 Apr 2020 23:01:08 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</guid>
      <description> CPA原理  CPA原理是分布式存储理论的基石： C(一致性)； A(可用性)； P(分区容忍性); 当主从网络无法连通时，修改操作无法同步到节点，所以“一致性”无法满足 除非我们牺牲“可用性”，也就是暂停分布式节点服务，不再提供修改数据功能，知道网络恢复  一句话概括CAP: 当网络分区发生时，一致性 和 可用性 两难全
redis主从同步介绍  和MySQL主从复制的原因一样，Redis虽然读取写入的速度都特别快，但是也会产生读压力特别大的情况。 为了分担读压力，Redis支持主从复制，Redis的主从结构可以采用一主多从或者级联结构。 Redis主从复制可以根据是否是全量分为全量同步和增量同步。  注：redis主节点Master挂掉时，运维让从节点Slave接管（redis主从默认无法自动切换，需要运维手动切换）
全量同步（快照同步） 注：Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。
具体步骤如下：
 从服务器连接主服务器，发送SYNC命令； 主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令； 主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令； 从服务器收到快照文件后丢弃所有旧数据，载入收到的快照； 主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令； 从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令； 完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。  增量同步  主节点会将那些对自己状态产生修改性影响的指令记录在本地内存buffer中，然后异步将buffer中指令同步到从节点 从节点一边执行同步指令达到主节点状态，一边向主节点反馈自己同步到哪里（偏移量） 当网络状态不好时，从节点无法和主节点进行同步，当网络恢复时需要进行快照同步  Redis主从同步策略  主从刚刚连接的时候，进行全量同步；全同步结束后，进行增量同步。 当然，如果有需要，slave 在任何时候都可以发起全量同步。 redis 策略是，无论如何，首先会尝试进行增量同步，如不成功，要求从机进行全量同步。  注意点  如果多个Slave断线了，需要重启的时候，因为只要Slave启动，就会发送sync请求和主机全量同步，当多个同时出现的时候，可能会导致Master IO剧增宕机。  </description>
    </item>
    
    <item>
      <title>Redis雪崩_穿透_击穿</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E9%9B%AA%E5%B4%A9_%E7%A9%BF%E9%80%8F_%E5%87%BB%E7%A9%BF/</link>
      <pubDate>Sun, 12 Apr 2020 22:59:08 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E9%9B%AA%E5%B4%A9_%E7%A9%BF%E9%80%8F_%E5%87%BB%E7%A9%BF/</guid>
      <description> 缓存穿透  定义   缓存穿透是指查询一个一定不存在的数据，由于缓存不命中，接着查询数据库也无法查询出结果， 虽然也不会写入到缓存中，但是这将会导致每个查询都会去请求数据库，造成缓存穿透；   解决方法 ：布隆过滤   对所有可能查询的参数以hash形式存储，在控制层先进行校验，不符合则丢弃，从而避免了对底层存储系统的查询压力；  缓存雪崩  定义　   缓存雪崩是指，由于缓存层承载着大量请求，有效的保护了存储层，但是如果缓存层由于某些原因整体不能提供服务 于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会挂掉的情况。   解决方法   保证缓存层服务高可用性：比如 Redis Sentinel 和 Redis Cluster 都实现了高可用 依赖隔离组件为后端限流并降级：比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。  缓存击穿  定义：   缓存击穿，就是说某个 key 非常热点，访问非常频繁，处于集中式高并发访问的情况 当这个 key 在失效的瞬间，大量的请求就击穿了缓存，直接请求数据库，就像是在一道屏障上凿开了一个洞。   解决方法   解决方式也很简单，可以将热点数据设置为永远不过期； 或者基于 redis or zookeeper 实现互斥锁，等待第一个请求构建完缓存之后，再释放锁，进而其它请求才能通过该 key 访问数据  </description>
    </item>
    
    <item>
      <title>Redis布隆过滤器</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</link>
      <pubDate>Sun, 12 Apr 2020 22:55:23 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/</guid>
      <description> 布隆过滤器是什么？（判断某个key一定不存在）  本质上布隆过滤器是一种数据结构，比较巧妙的概率型数据结构 特点是高效地插入和查询，可以用来告诉你 “某样东西一定不存在或者可能存在”。 相比于传统的 List、Set、Map 等数据结构，它更高效、占用空间更少，但是缺点是其返回的结果是概率性的，而不是确切的。  使用：
 布隆过滤器在NoSQL数据库领域中应用的非常广泛 当用户来查询某一个row时，可以先通过内存中的布隆过滤器过滤掉大量不存在的row请求，然后去再磁盘进行查询 布隆过滤器说某个值不存在时，那肯定就是不存在，可以显著降低数据库IO请求数量  应用场景  场景1（给用户推荐新闻）
 当用户看过的新闻，肯定会被过滤掉，对于没有看多的新闻，可能会过滤极少的一部分（误判）。
这样可以完全保证推送给用户的新闻都是无重复的。
 场景2（爬虫url去重）
 在爬虫系统中，我们需要对url去重，已经爬取的页面不再爬取
当url高达几千万时，如果一个集合去装下这些URL地址非常浪费空间
使用布隆过滤器可以大幅降低去重存储消耗，只不过也会使爬虫系统错过少量页面
  布隆过滤器原理  每个布隆过滤器对应到Redis的数据结构是一个大型的数组和几个不一样的无偏hash函数 如下图：f、g、h就是这样的hash函数（无偏差指让hash映射到数组的位置比较随机）   添加：值到布隆过滤器
 向布隆过滤器添加key,会使用 f、g、h hash函数对key算出一个整数索引，然后对长度取余
每个hash函数都会算出一个不同的位置，把算出的位置都设置成1就完成了布隆过滤器添加过程
 查询：布隆过滤器值
 当查询某个key时，先用hash函数算出一个整数索引，然后对长度取余
当你有一个不为1时肯定不存在这个key，当全部都为1时可能有这个key
这样内存中的布隆过滤器过滤掉大量不存在的row请求，然后去再磁盘进行查询，减少IO操作
   删除：不支持
 目前我们知道布隆过滤器可以支持 add 和 isExist 操作
如何解决这个问题，答案是计数删除，但是计数删除需要存储一个数值，而不是原先的 bit 位，会增大占用的内存大小。
增加一个值就是将对应索引槽上存储的值加一，删除则是减一，判断是否存在则是看值是否大于0。
  </description>
    </item>
    
    <item>
      <title>Redis分布式锁</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</link>
      <pubDate>Sun, 12 Apr 2020 22:53:06 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</guid>
      <description>redis事务  严格意义来讲,Redis的事务和我们理解的传统数据库(如mysql)的事务是不一样的； Redis的事务实质上是命令的集合，在一个事务中要么所有命令都被执行，要么所有命令都不执行。  需要注意的是:
 Redis的事务没有关系数据库事务提供的回滚（rollback），所以开发者必须在事务执行失败后进行后续的处理； 如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 如果在一个事务中出现运行错误，那么正确的命令会被执行。  redis原子操作  原子操作是指不会被线程调度机制打断的操作 这种操作一旦开始，就会一直运行到结束，中间不会切换任何进程  分布式锁   分布式锁本质是占一个坑，当别的进程也要来占坑时发现已经被占，就会放弃或者稍后重试
  占坑一般使用 setnx(set if not exists)指令，只允许一个客户端占坑
  先来先占，用完了在调用del指令释放坑
 &amp;gt; setnx lock:codehole true .... do something critical .... &amp;gt; del lock:codehole    但是这样有一个问题，如果逻辑执行到中间出现异常，可能导致del指令没有被调用，这样就会陷入死锁，锁永远无法释放
  为了解决死锁问题，我们拿到锁时可以加上一个expire过期时间，这样即使出现异常，当到达过期时间也会自动释放锁
 &amp;gt; setnx lock:codehole true &amp;gt; expire lock:codehole 5 .... do something critical .... &amp;gt; del lock:codehole    这样又有一个问题，setnx和expire是两条指令而不是原子指令，如果两条指令之间进程挂掉依然会出现死锁</description>
    </item>
    
    <item>
      <title>Redis事务</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Sun, 12 Apr 2020 22:51:17 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E4%BA%8B%E5%8A%A1/</guid>
      <description> redis事务介绍  redis事务是可以一次执行多个命令，本质是一组命令的集合。 一个事务中的所有命令都会序列化，按顺序串行化的执行而不会被其他命令插入  作用：一个队列中，一次性、顺序性、排他性的执行一系列命令
redis事务基本使用  下面指令演示了一个完整的事务过程，所有指令在exec前不执行，而是缓存在服务器的一个事务队列中 服务器一旦收到exec指令才开始执行事务队列，执行完毕后一次性返回所有结果 因为redis是单线程的，所以不必担心自己在执行队列是被打断，可以保证这样的“原子性”  注：redis事务在遇到指令失败后，后面的指令会继续执行
mysql的rollback与redis的discard的区别:
  mysql回滚为sql全部成功才执行,一条sql失败则全部失败,执行rollback后所有语句造成的影响消失
  redis的discard只是结束本次事务,正确命令造成的影响仍然还在.
 &amp;gt; multi（开始一个redis事务） incr books incr books &amp;gt; exec （执行事务） &amp;gt; discard （丢弃事务）    watch指令  watch其实就是redis提供的一种乐观锁，可以解决并发修改问题 watch会在事务开始前盯住一个或多个关键变量，当服务器收到exec指令要顺序执行缓存中的事务队列时 redis会检查关键变量自watch后是否被修改（包括当前事务所在的客户端） 如果关键变量被人改动过，exec指令就会返回null回复告知客户端事务执行失败，这个时候客户端会选择重试 注：redis禁用在multi和exec之间执行watch指令，必须在multi之前盯住关键变量，否则会出错  </description>
    </item>
    
    <item>
      <title>Redis的五大数据类型实现原理</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 12 Apr 2020 22:48:39 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/redis%E7%9A%84%E4%BA%94%E5%A4%A7%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</guid>
      <description> 说明：  redis中所有数据结构都以唯一的key字符串作为名称，然后通过这个唯一的key来获取对应的value 不同的数据类型数据结构差异就在于value的结构不一样  1. 字符串（string） value的数据结构（数组）  字符串value数据结构类似于数组，采用与分配容易空间来减少内存频繁分配 当字符串长度小于1M时，扩容就是加倍现有空间 如果字符串长度操作1M时，扩容时最多扩容1M空间，字符串最大长度为 512M  字符串的使用场景（缓存）  字符串一个常见的用途是缓存用户信息，我们将用户信息使用JSON序列化成字符串 取用户信息时会经过一次反序列化的过程  2. list（列表） value的数据结构（双向链表）  列表的数据结构是双向链表，这意味着插入和删除的时间复杂度是0(1)，索引的时间复杂度位0(n) 当列表弹出最后一个元素后，该数据结构会被自动删除，内存被回手  列表的使用场景（队列、栈） 3. hash（字典） value的数据结构（HashMap）  redis中的字典也是HashMap（数组+列表）的二维结构 不同的是redis的字典的值只能是字符串  hash的使用场景（缓存）  hash可以用来缓存用户信息，与字符串一次性全部序列化整个对象不同，hash可以对每个字段进行单独存储 这样可以部分获取用户信息，节约网络流量 hash也有缺点，hash结构的存储消耗要高于单个字符串  </description>
    </item>
    
    <item>
      <title>MySQL 基于Docker的主从复制</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E5%9F%BA%E4%BA%8Edocker%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</link>
      <pubDate>Sun, 12 Apr 2020 22:44:47 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E5%9F%BA%E4%BA%8Edocker%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/</guid>
      <description>场景需求 今天老板要求 docker 搭建mysql 主从同步，头皮发麻，无从下手，要求：使用docker，并说明使用docker搭建得好处，实现原理，搭建具体过程。
参考答案 好处：
 一台服务器可以运行多个docker容器。 docker 容器之间相互独立，互不冲突。 docker 使用步骤简便。  具体实现步骤：
首先基于docker拉取mysql镜像 docker pull mysql:5.7
使用下载好的镜像，启动主从两个容器 docker run -p 3339:3306 --name mymysql –e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 # 主 docker run -p 3340:3306 --name mymysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7 # 从  配置主从 docker exec -it 627a2368c865 /bin/bash # 进入容器，627a2368c865是容器的id,而mysql-master是容器的名称 apt-get update apt-get install vim # 在容器中手动安装 vim  vi my.cnf，进入/etc/mysql目录下，对my.cnf进行编辑 [mysqld] server-id = 100 log-bin = mysql-bin service mysql restart # 重启mysql docker start mysql-master # 启动容器  创建主从所需权限用户 CREATE USER &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39; # 创建用户 GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.</description>
    </item>
    
    <item>
      <title>MySQL 主从一致校验</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%A0%A1%E9%AA%8C/</link>
      <pubDate>Sun, 12 Apr 2020 22:37:38 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E4%B8%BB%E4%BB%8E%E4%B8%80%E8%87%B4%E6%A0%A1%E9%AA%8C/</guid>
      <description>场景需求 2020年春，由我司开发的考试系统项目，经过不懈的运营努力，用户群体每日以指数倍激增，现考虑到数据库的安全可靠和访问性能问题，决定在业务中集成部署Mysql主从复制以实现读写分离等功能；巧的是，在想要进行主从复制操作前，我们的主要业务数据库已经工作了一段时间，现在要添加一台新的从数据库进行主从复制，通过一位发量稀少同事的一番操作，两台主机已经成功部署好了主从复制，但是我们该如何检测主从服务器的数据是否一致，如果不一致怎么同步数据？
参考答案 我们可以通过采用pt-table-checksum工具来检查主从的一致性，以下是具体流程。
工具安装 [root@MySQL-01 ~]# wget http://www.percona.com/get/percona-toolkit.tar.gz
安装所需依赖 [root@MySQL-01 ~]# yum install perl perl-devel perl-Time-HiRes perl-DBI perl-DBD-MySQL perl-Compress-Raw-Bzip2 perl-Compress-Raw-Zlib perl-Digest perl-Digest-MD5 perl-IO-Compress perl-IO-Socket-IP perl-IO-Socket-SSL perl-Mozilla-CA perl-Net-Daemon perl-Net-LibIDN perl-Net-SSLeay ...  安装工具 [root@MySQL-01 ~]# tar zxf percona-toolkit-2.2.13.tar.gz [root@MySQL-01 ~]# cd percona-toolkit-2.2.13 [root@MySQL-01 ~]# perl Makefile.PL [root@MySQL-01 ~]# make &amp;amp;&amp;amp; make install  在进行主从校验之前，我们首先需要对主从库进行授权，来看看如何来做吧 主库授权
root@node1 12:28: [pt_check]&amp;gt; GRANT CREATE,INSERT,SELECT,DELETE,UPDATE,LOCK TABLES,PROCESS,SUPER,REPLICATION SLAVE ON *.* TO &#39;root&#39;@&#39;47.97.218.145&#39; IDENTIFIED BY &#39;123456&#39;; Query OK, 0 rows affected (0.</description>
    </item>
    
    <item>
      <title>MySQL 慢查询应用</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%BA%94%E7%94%A8/</link>
      <pubDate>Sun, 12 Apr 2020 22:25:16 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql-%E6%85%A2%E6%9F%A5%E8%AF%A2%E5%BA%94%E7%94%A8/</guid>
      <description>场景需求 现我司发现，我司业务中部分接口相应极慢，用户甚至可以在等待过程中泡面，经由我司诸位人才讨论分析，需要使用mysql慢查询定位有问题的SQL语句，请您为我司说明什么是mysql慢查询及如何开启慢查询、其详细配置和使用方法。
参考答案 MySQL的慢查询，全名是慢查询日志，是MySQL提供的一种日志记录，用来记录在MySQL中响应时间超过阀值的语句。具体环境中，运行时间超过long_query_time值的SQL语句，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是记录运行10秒以上的语句。默认情况下，MySQL数据库并不启动慢查询日志，需要手动来设置这个参数。
当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。
此外，慢查询日志支持将日志记录写入文件和数据库表。
MySQL 慢查询的相关参数解释：  slow_query_log：是否开启慢查询日志，1表示开启，0表示关闭。 log-slow-queries ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log long_query_time：慢查询阈值，当查询时间多于设定的阈值时，记录日志。 log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。 log_output：日志存储方式。log_output=&#39;FILE&#39;表示将日志存入文件，默认值是&amp;rsquo;FILE&amp;rsquo;。log_output=&#39;TABLE&#39;表示将日志存入数据库。  那么如何进行慢查询日志的配置呢？默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，可以通过设置slow_query_log的值来开启，如下所示：
show variables like &#39;%slow_query_log%&#39;; +----------------------+-----------------------------------------------+ | Variable_name | Value | +----------------------+-----------------------------------------------+ | slow_query_log | OFF | | slow_query_log_file | /home/WDPM/MysqlData/mysql/DB-Server-slow.log | +----------------------+------------------------------------------------+ 2 rows in set (0.00 sec)  使用set global slow_query_log=1开启了慢查询日志只对当前数据库生效，MySQL重启后则会失效。如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此）
set global slow_query_log=1;  my.cnf要增加或修改参数slow_query_log 和slow_query_log_file，如下所示：
slow_query_log = 1 slow_query_log_file = /tmp/mysql_slow.log  slow_query_log_file这个参数用于指定慢查询日志的存放路径，缺省情况是host_name-slow.log文件。
show variables like &#39;slow_query_log_file&#39;; +---------------------+-----------------------------------------------+ | Variable_name | Value | +---------------------+-----------------------------------------------+ | slow_query_log_file | /home/WDPM/MysqlData/mysql/DB-Server-slow.</description>
    </item>
    
    <item>
      <title>MySQL主从同步原理</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sun, 12 Apr 2020 22:24:24 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5%E5%8E%9F%E7%90%86/</guid>
      <description>   master服务器将数据的改变记录二进制binlog日志，当master上的数据发生改变时，则将其改变写入二进制日志中；
  slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件
  同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。
  </description>
    </item>
    
    <item>
      <title>B&#43;tree</title>
      <link>/blog/%E5%85%B6%E4%BB%96/06-b&#43;tree/</link>
      <pubDate>Sun, 12 Apr 2020 22:16:07 +0800</pubDate>
      
      <guid>/blog/%E5%85%B6%E4%BB%96/06-b&#43;tree/</guid>
      <description> 以一个3阶的B-Tree举例   每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。
  两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。
  以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。
 &#39;&#39;&#39;模拟查找关键字29的过程：&#39;&#39;&#39; # 根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】 # 比较关键字29在区间（17,35），找到磁盘块1的指针P2。 # 根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】 # 比较关键字29在区间（26,30），找到磁盘块3的指针P2。 # 根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】 # 在磁盘块8中的关键字列表中找到关键字29。    B+tree(以每个节点可存4个键值及指针信息为例)  B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息 在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。 因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。  </description>
    </item>
    
    <item>
      <title>MySQL优化</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BC%98%E5%8C%96/</link>
      <pubDate>Sun, 12 Apr 2020 22:12:45 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BC%98%E5%8C%96/</guid>
      <description>  字段设计优化 适应遵循数据库三范式 引擎的选择 适应选择MyIsam &amp;amp; InnoDB 索引 索引也会消耗内存空间，并不是越多越好。而且索引的种类都有各自的有点 查询缓存 将 select查询结果缓存起来，key 为SQL语句，value 为查询结果 分区 水平分割和垂直分割 集群 SQL语句 服务器的选择 选择配置较高的服务器  为什么要MySQL优化？
 系统的吞吐量瓶颈往往出现在数据库的访问速度上 随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢 为了避免慢查询的出现  </description>
    </item>
    
    <item>
      <title>MySQL中的锁</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%AD%E7%9A%84%E9%94%81/</link>
      <pubDate>Sun, 12 Apr 2020 22:11:03 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%B8%AD%E7%9A%84%E9%94%81/</guid>
      <description> 锁分类  按操作划分：DML锁，DDL锁 按锁的粒度划分：表级锁、行级锁、页级锁 按锁级别划分：共享锁、排他锁 按加锁方式划分：自动锁、显示锁 按使用方式划分：乐观锁、悲观锁  乐观锁   每次获取商品时，不对该商品加锁。
  在更新数据的时候需要比较程序中的库存量与数据库中的库存量是否相等，如果相等则进行更新
  反之程序重新获取库存量，再次进行比较，直到两个库存量的数值相等才进行数据更新。
 #### 乐观锁实现加一操作代码 # 我们可以看到，只有当对数量-1操作时才会加锁，只有当程序中值和数据库中的值相等时才正真执行。 &#39;&#39;&#39; //不加锁 select id,name,stock where id=1; //业务处理 begin; update shop set stock=stock-1 where id=1 and stock=stock; commit; &#39;&#39;&#39;    悲观锁   每次获取商品时，对该商品加排他锁。
  也就是在用户A获取获取 id=1 的商品信息时对该行记录加锁，期间其他用户阻塞等待访问该记录。
 #### 悲观锁实现加一操作代码 # 我们可以看到，首先通过begin开启一个事物，在获得shop信息和修改数据的整个过程中都对数据加锁，保证了数据的一致性。 &#39;&#39;&#39; begin; select id,name,stock as old_stock from shop where id=1 for update; update shop set stock=stock-1 where id=1 and stock=old_stock; commit &#39;&#39;&#39;    排它锁  排它锁又叫写锁，如果事务T对A加上排它锁，则其它事务都不能对A加任何类型的锁。获准排它锁的事务既能读数据，又能写数据。 用法 ： SELECT … FOR UPDATE  共享锁(share lock)  共享锁又叫读锁，如果事务T对A加上共享锁，则其它事务只能对A再加共享锁，不能加其它锁。 获准共享锁的事务只能读数据，不能写数据。 用法： SELECT … LOCK IN SHARE MODE;  </description>
    </item>
    
    <item>
      <title>MySQL事务</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1/</link>
      <pubDate>Sun, 12 Apr 2020 22:08:49 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql%E4%BA%8B%E5%8A%A1/</guid>
      <description>InnoDB事务原理  事务（Transaction）是数据库区别于文件系统的重要特性之一，事务会把数据库从一种一致性状态转换为另一种一致性状态。 在数据库提交时，可以确保要么所有修改都已保存，要么所有修改都不保存。  事务的（ACID）特征  原子性(Atomicity)：整个事务的所有操作要么全部提交成功，要么全部失败回滚(不会出现部分执行的情况)。 一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。 隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。 持久性(Durability): 一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。  事务隔离级别   读未提交（Read Uncommitted）：可以读取其它事务未提交的记录，会出现脏读、幻读、不可重复读等问题。
  读已提交（Read Committed）：一个事务提交后所做的变更才能被其它事务看到，不会出现脏读，但是会出现幻读、不可重复读。（大多数数据库的默认隔离级别都是 RC。InnoDB 默认是 RR）。
  可重复读（Repeatable Read）：事务执行过程中看到一致性的数据视图，解决了不可重复读问题，但是仍然存在幻读问题.（InnoDB通过MVCC+GAP间隙锁也解决了幻读）。
  序列化（Serializable）：“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成,没有并发问题。
   未提交读: 脏读（READ UNCOMMITTED）   事务2查询到的数据是事务1中修改但未提交的数据，但因为事务1回滚了数据
  所以事务2查询的数据是不正确的，因此出现了脏读的问题。
 提交读: 不可重复读（READ COMMITTED）   事务2执行update语句但未提交前，事务1的前两个select操作返回结果是相同的。
  但事务2执行commit操作后，事务1的第三个select操作就读取到事务2对数据的改变。
  导致与前两次select操作返回不同的数据，因此出现了不可重复读的问题。
 可重复读: 幻读（REPEATABLE READ）：这是MySQL的默认事务隔离级别   事务每开启一个实例，都会分配一个版本号给它，如果读取的数据行正在被其它事务执行DELETE或UPDATE操作（即该行上有排他锁）
  这时该事务的读取操作不会等待行上的锁释放，而是根据版本号去读取行的快照数据（记录在undo log中）
  这样，事务中的查询操作返回的都是同一版本下的数据，解决了不可重复读问题。</description>
    </item>
    
    <item>
      <title>高阶函数</title>
      <link>/blog/python/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 12 Apr 2020 22:04:34 +0800</pubDate>
      
      <guid>/blog/python/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</guid>
      <description>匿名函数 lambda   lambda只是一个表达式，函数体比def简单很多。
  lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。
  lambda表达式是起到一个函数速写的作用。允许在代码内嵌入一个函数的定义。
  格式：lambda的一般形式是关键字lambda后面跟一个或多个参数，紧跟一个冒号，之后是一个表达式。
 f = lambda x,y,z:x+y+z print(f(1,2,3)) # 6 my_lambda = lambda arg : arg + 1 print(my_lambda(10)) # 11    三元运算   三元运算格式： result=值1 if x&amp;lt;y else 值2 if条件成立result=1,否则result=2
  作用：三元运算，又称三目运算，主要作用是减少代码量，是对简单的条件语句的缩写
 name = &#39;Tom&#39; if 1 == 1 else &#39;fly&#39; print(name) # 运行结果： Tom f = lambda x:x if x % 2 !</description>
    </item>
    
    <item>
      <title>上下文管理</title>
      <link>/blog/python/%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86/</link>
      <pubDate>Sun, 12 Apr 2020 22:03:11 +0800</pubDate>
      
      <guid>/blog/python/%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86/</guid>
      <description> 什么是with语句  with是一种上下文管理协议，目的在于从流程图中把 try,except 和finally 关键字和资源分配释放相关代码统统去掉，简化try….except….finlally的处理流程。 所以使用with处理的对象必须有enter()和exit()这两个方法   with通过enter方法初始化（enter方法在语句体执行之前进入运行）
  然后在exit中做善后以及处理异常（exit()方法在语句体执行完毕退出后运行）
 with语句使用场景  with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源 比如文件使用后自动关闭、线程中锁的自动获取和释放等。  with处理文件操作的实例 with open(&#39;/etc/passwd&#39;) as f: for line in f: print(line) # 这段代码的作用：打开一个文件，如果一切正常，把文件对象赋值给f，然后用迭代器遍历文件中每一行，当完成时，关闭文件； # 而无论在这段代码的任何地方，如果发生异常，此时文件仍会被关闭。  </description>
    </item>
    
    <item>
      <title>Python垃圾回收机制</title>
      <link>/blog/python/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</link>
      <pubDate>Sun, 12 Apr 2020 21:54:04 +0800</pubDate>
      
      <guid>/blog/python/python%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</guid>
      <description> 引用计数  当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁时，对象的引用计数减1. 当对象的引用计数减少为0时，就意味着对象已经再没有被使用了，可以将其内存释放掉。  标记－清除  它分为两个阶段：第一阶段是标记阶段，GC会把所有的活动对象打上标记，第二阶段是把那些没有标记的对象非活动对象进行回收。 对象之间通过引用（指针）连在一起，构成一个有向图 从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象，根对象就是全局变量、调用栈、寄存器。   在上图中，可以从程序变量直接访问块1，并且可以间接访问块2和3,程序无法访问块4和5 第一步将标记块1，并记住块2和3以供稍后处理。 第二步将标记块2，第三步将标记块3，但不记得块2，因为它已被标记。 扫描阶段将忽略块1，2和3，因为它们已被标记，但会回收块4和5。  分代回收  分代回收是建立在标记清除技术基础之上的，是一种以空间换时间的操作方式。 Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代） 他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。 新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发 把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推 老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。  </description>
    </item>
    
    <item>
      <title>深浅拷贝</title>
      <link>/blog/python/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</link>
      <pubDate>Sun, 12 Apr 2020 21:52:31 +0800</pubDate>
      
      <guid>/blog/python/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</guid>
      <description> 预备知识——python的变量及其存储  python的一切变量都是对象，变量的存储，采用了引用语义的方式，存储的只是一个变量的值所在的内存地址，而不是这个变量的只本身 不管多么复杂的数据结构，浅拷贝都只会copy一层。 理解：两个人公用一张桌子，只要桌子不变，桌子上的菜发生了变化两个人是共同感受的。  浅copy与deepcopy   copy：不管多么复杂的数据结构，浅拷贝都只会copy一层
  deepcopy：深拷贝会完全复制原变量相关的所有数据，在内存中生成一套完全一样的内容，我们对这两个变量中任意一个修改都不会影响其他变量
 import copy sourceList = [1,2,3,[4,5,6]] copyList = copy.copy(sourceList) deepcopyList = copy.deepcopy(sourceList) sourceList[3][0]=100 print(sourceList) # [1, 2, 3, [100, 5, 6]] print(copyList) # [1, 2, 3, [100, 5, 6]] print(deepcopyList) # [1, 2, 3, [4, 5, 6]]    </description>
    </item>
    
    <item>
      <title>面向对象</title>
      <link>/blog/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Sun, 12 Apr 2020 21:39:27 +0800</pubDate>
      
      <guid>/blog/python/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</guid>
      <description>封装，继承，多态 1. 封装  在类中对数据的赋值、内部调用对外部用户是透明的 这使类变成了一个胶囊或容器，里面包含着类的数据和方法 作用：   防止数据被随意修改
  使外部程序不需要关注对象内部的构造，只需要通过对外提供的接口进行直接访问
 2．Inheritance 继承（代码重用）  一个类可以派生出子类，在这个父类里定义的属性、方法自动被子类继承 比如CS中的警察和恐怖分子，可以将两个角色的相同点写到一个父类中，然后同时去继承它 使用经典类： Person.__init__(self,name,age) 并重写写父类Person的构造方法，实现，先覆盖，再继承，再重构  3. Polymorphism 多态（接口重用）  多态是面向对象的重要特性,简单点说:“一个接口，多种实现” 指一个基类中派生出了不同的子类，且每个子类在继承同样的方法名的同时又对父类的方法做了不同的实现 这就是同一种事物表现出的多种形态 比如黄种人继承了人talk这个功能，但是他说的是中文，而美国人的talk是英文，但是他们是同样的talk  作用：简单的讲就是允许父类调用子类的方法
静态方法、类方法、属性方法 静态方法  作用: 静态方法可以更好的组织代码，防止代码变大后变得比较混乱。 特性: 静态方法只是名义上归类管理，实际上在静态方法里访问不了类或则实例中的任何属性 静态方法使用场景：   我们要写一个只在类中运行而不在实例中运行的方法.
  经常有一些跟类有关系的功能但在运行时又不需要实例和类参与的情况下需要用到静态方法.
  比如更改环境变量或者修改其他类的属性等能用到静态方法.
  这种情况可以直接用函数解决, 但这样同样会扩散类内部的代码，造成维护困难.
  调用方式: 既可以被类直接调用，也可以通过实例调用
 class Dog(object): def __init__(self,name): self.name = name @staticmethod def eat(): print(&amp;quot;I am a static method&amp;quot;) d = Dog(&amp;quot;ChenRonghua&amp;quot;) d.</description>
    </item>
    
    <item>
      <title>迭代器</title>
      <link>/blog/python/%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Sun, 12 Apr 2020 21:37:01 +0800</pubDate>
      
      <guid>/blog/python/%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description> 1. 迭代器定义  迭代器是访问集合内元素的方式，迭代器对象从集合的第一个元素开始访问，直到所有的元素都被访问一遍后结束 迭代器仅是一容器对象，它有两个基本方法   next方法：返回容器的下一个元素
  __iter__方法：返回迭代器自身
 a = iter([1,2,]) #生成一个迭代器 print(a.__next__()) print(a.__next__()) print(a.__next__()) #在这一步会引发 “StopIteration” 的异常  2. 生成器和迭代器之间的区别  在使用生成器时，我们创建一个函数；在使用迭代器时，我们使用内置函数iter()和next()。 在生成器中，我们使用关键字yield来每次生成/返回一个对象。 生成器中有多少yield语句，你可以自定义。 每次yield暂停循环时，生成器会保存本地变量的状态。而迭代器并不会使用局部变量，它只需要一个可迭代对象进行迭代。 使用类可以实现你自己的迭代器，但无法实现生成器。 生成器运行速度快，语法简洁，更简单。 迭代器更能节约内存。
 </description>
    </item>
    
    <item>
      <title>生成器</title>
      <link>/blog/python/%E7%94%9F%E6%88%90%E5%99%A8/</link>
      <pubDate>Sun, 12 Apr 2020 21:34:53 +0800</pubDate>
      
      <guid>/blog/python/%E7%94%9F%E6%88%90%E5%99%A8/</guid>
      <description> 1. 生成器定义 生成器可以理解为一种数据类型，这种数据类型自动实现了迭代器协议（其他数据类型需要调用自己的内置iter方法）
在Python中，一边循环，一边计算的机制，称为生成器。
2. 生成器的作用  通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的。 而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？ 这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。  3. 生成器工作原理  生成器是这样一个函数，它记住上一次返回时在函数体中的位置。 对生成器函数的第二次（或第 n 次）调用跳转至该函数中间，而上次调用的所有局部变量都保持不变。 生成器不仅“记住”了它数据状态；生成器还“记住”了它在流控制构造中的位置。 生成器是一个函数，而且函数的参数都会保留。 迭代到下一次的调用时，所使用的参数都是第一次所保留下的，即是说，在整个所有函数调用的参数都是第一次所调用时保留的，而不是新创建的  4. yield生成器运行机制 在Python中，yield就是这样的一个生成器。
  当你问生成器要一个数时，生成器会执行，直至出现 yield 语句，生成器把yield 的参数给你，之后生成器就不会往下继续运行。
  当你问他要下一个数时，他会从上次的状态开始运行，直至出现yield语句，把参数给你，之后停下。如此反复
  在python中，当你定义一个函数，使用了yield关键字时，这个函数就是一个生成器
  它的执行会和其他普通的函数有很多不同，函数返回的是一个对象，而不是你平常所用return语句那样，能得到结果值。如果想取得值，那得调用next()函数
  每当调用一次迭代器的next函数，生成器函数运行到yield之处，返回yield后面的值且在这个地方暂停，所有的状态都会被保持住，直到下次next函数被调用，或者碰到异常循环退出。
 # yield实现fib数 def fib(max_num): a,b = 1,1 while a &amp;lt; max_num: yield b a,b=b,a+b g = fib(10) #生成一个生成器：[1，2, 3, 5, 8, 13] print(g.__next__()) #第一次调用返回：1 print(list(g)) #把剩下元素变成列表：[2, 3, 5, 8, 13]    </description>
    </item>
    
    <item>
      <title>装饰器</title>
      <link>/blog/python/%E8%A3%85%E9%A5%B0%E5%99%A8/</link>
      <pubDate>Sun, 12 Apr 2020 21:33:27 +0800</pubDate>
      
      <guid>/blog/python/%E8%A3%85%E9%A5%B0%E5%99%A8/</guid>
      <description>1. 装饰器定义 不能修改被装饰函数的源代码，不能修改被装饰函数的调用方式，为其他函数添加其他功能
2. 使用高阶函数模拟装饰器 #! /usr/bin/env python # -*- coding: utf-8 -*- import time def timer(func): start_time = time.time() func() print &#39;函数执行时间为&#39;, time.time() - start_time def test(): print &#39;开始执行test&#39; time.sleep(3) print &#39;test执行结束&#39; timer(test) &#39;&#39;&#39; 开始执行test test执行结束 函数执行时间为 3.00332999229 &#39;&#39;&#39;  3. 计算运行时间装饰器 import time def timer(func): #timer(test1) func=test1 def deco(*args,**kwargs): start_time = time.time() func(*args,**kwargs) #run test1 stop_time = time.time() print(&amp;quot;running time is %s&amp;quot;%(stop_time-start_time)) return deco @timer # test1=timer(test1) def test1(): time.</description>
    </item>
    
    <item>
      <title>Sellect_poll_epoll</title>
      <link>/blog/linux/sellect_poll_epoll/</link>
      <pubDate>Sun, 12 Apr 2020 21:30:55 +0800</pubDate>
      
      <guid>/blog/linux/sellect_poll_epoll/</guid>
      <description>1. select （能监控数量有限，不能告诉用户程序具体哪个连接有数据）  select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点 select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024 select监控socket连接时不能准确告诉用户是哪个，比如：现在用socket监控10000链接，如果其中有一个链接有数据了，select就会告诉用户程序，你有socket来数据了，那样就只能自己循环10000次判断哪个活跃  2. poll（和select一样，仅仅去除了最大监控数量）  poll和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制 可以理解为poll是一个过渡阶段，大家也都不用他  3. epoll (不仅没有最大监控数量限制，还能告诉用户程序哪个连接有活跃) epoll被认为是linux下性能最好的多路io就绪通知方法
 epoll直到Linux2.6（centos6以后）才出现了由内核直接支持 Epoll没有最大文件描述符数量限制 epoll最重要的优点是他可以直接告诉用户程序哪一个，比如现在用epoll去监控10000个socket链接，交给内核去监测，现在有一个连接有数据了，在有有一个连接有数据了，epoll会直接高数用户程序哪个连接有数据了  4. epoll能实现高并发原理  epoll() 中内核则维护一个链表，epoll_wait 直接检查链表是不是空就知道是否有文件描述符准备好了。 在内核实现中 epoll 是根据每个 sockfd 上面的与设备驱动程序建立起来的回调函数实现的。 某个 sockfd 上的事件发生时，与它对应的回调函数就会被调用，把这个 sockfd 加入链表。 epoll上面链表中获取文件描述，这里使用内存映射（mmap）技术， 避免了复制大量文件描述符带来的开销  内存映射文件，是由一个文件到一块内存的映射，将不必再对文件执行I/O操作</description>
    </item>
    
    <item>
      <title>协程</title>
      <link>/blog/python/%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Sun, 12 Apr 2020 21:28:29 +0800</pubDate>
      
      <guid>/blog/python/%E5%8D%8F%E7%A8%8B/</guid>
      <description>1. 什么是协程（进入上一次调用的状态）  协程，又称微线程，纤程，协程是一种用户态的轻量级线程。 线程的切换会保存到CPU的栈里，协程拥有自己的寄存器上下文和栈， 协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈 协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态 协程最主要的作用是在单线程的条件下实现并发的效果，但实际上还是串行的（像yield一样）  2. 协程缺点(无法利用多核资源) 协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上线程阻塞（Blocking）操作（如IO时）会阻塞掉整个程序
3. 协程为何能处理大并发1：Greenlet遇到I/O手动切换  协程之所以快是因为遇到I/O操作就切换（最后只有CPU运算） 这里先演示用greenlet实现手动的对各个协程之间切换 其实Gevent模块仅仅是对greenlet的再封装，将I/O间的手动切换变成自动切换  4. 协程为何能处理大并发2：Gevent遇到I/O自动切换  Gevent 是一个第三方库，可以轻松通过gevent实现并发同步或异步编程 在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。 Gevent原理是只要遇到I/O操作就会自动切换到下一个协程  5. 使用协程处理并发 Gevent只用起一个线程，当请求发出去后gevent就不管,永远就只有一个线程工作，谁先回来先处理
import gevent import requests from gevent import monkey monkey.patch_all() # 这些请求谁先回来就先处理谁 def fetch_async(method, url, req_kwargs): response = requests.request(method=method, url=url, **req_kwargs) print(response.url, response.content) # ##### 发送请求 ##### gevent.joinall([ gevent.spawn(fetch_async, method=&#39;get&#39;, url=&#39;https://www.python.org/&#39;, req_kwargs={}), gevent.spawn(fetch_async, method=&#39;get&#39;, url=&#39;https://www.google.com/&#39;, req_kwargs={}), gevent.</description>
    </item>
    
    <item>
      <title>线程</title>
      <link>/blog/python/%E7%BA%BF%E7%A8%8B/</link>
      <pubDate>Sun, 12 Apr 2020 21:22:30 +0800</pubDate>
      
      <guid>/blog/python/%E7%BA%BF%E7%A8%8B/</guid>
      <description>1. 线程定义   线程是操作系统调度的最小单位
  它被包含在进程中，是进程中的实际运作单位
  进程本身是无法自己运行的，要操作cpu，必须创建一个线程，线程是一系列指令的集合
 线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务 无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行 进程本身是无法自己执行的，要操作cpu，必须创建一个线程，线程是一系列指令的集合 所有在同一个进程里的线程是共享同一块内存空间的，不同进程间内存空间不同 同一个进程中的各线程可以相互访问资源，线程可以操作同进程中的其他线程，但进程仅能操作子进程 两个进程想通信，必须要通过一个中间代理 对主线程的修改可能回影响其他子线程，对主进程修改不会影响其他进程因为进程间内存相互独立，但是同一进程下的线程共享内存    2. 进程和线程的区别  进程包含线程 线程共享内存空间 进程内存是独立的（不可互相访问） 进程可以生成子进程，子进程之间互相不能互相访问（相当于在父级进程克隆两个子进程） 在一个进程里面线程之间可以交流。两个进程想通信，必须通过一个中间代理来实现 创建新线程很简单，创建新进程需要对其父进程进行克隆。 一个线程可以控制或操作同一个进程里面的其它线程。但进程只能操作子进程。 父进程可以修改不影响子进程，但不能修改。 线程可以帮助应用程序同时做几件事  3. for循环同时启动多个线程 import threading import time def sayhi(num): #定义每个线程要运行的函数 print(&amp;quot;running on number:%s&amp;quot; %num) time.sleep(3) for i in range(50): t = threading.Thread(target=sayhi,args=(&#39;t-%s&#39;%i,)) t.start()  4. t.join()： 实现所有线程都执行结束后再执行主线程 import threading import time start_time = time.</description>
    </item>
    
    <item>
      <title>进程</title>
      <link>/blog/python/%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Sun, 12 Apr 2020 20:33:12 +0800</pubDate>
      
      <guid>/blog/python/%E8%BF%9B%E7%A8%8B/</guid>
      <description>进程的定义   进程是资源分配的最小单位
  当一个可执行程序被系统执行（分配内存等资源）时，程序就变成了一个进程
程序并不能单独运行，程序只是指令的集合，是进程运行的静态描述文本。只有将程序装载到内存中，系统为它分配资源才能运行。程序执行，就称为进程。进程属于动态概念。
在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以并发地执行。
进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。也就是说，如果没有进程这个概念，一个CPU只能同时启动一个程序，要想用多个程序，就必须来回切换。
有了进程，就能让这些程序有各自独立的内存空间。这些进程之间不能相互访问。
创建一个新线程很简单，创建新进程需要对父进程进行复制。
· 多道编程：在计算机内同时存放几道相互独立的内存，他们共享资源，相互穿插进行
· 单道编程：在计算机内存中只允许一个程序运行。
  进程与程序  程序只是一个文件，是一个机器代码指令和数据的集合，所以，程序是一个静态的实体。 而进程是程序运行在数据集上的动态过程。进程是一个动态实体，它应创建而产生，因调度执行而运行，因等待资源或时间而被处于等待状态，因完成任务而被撤销。 进程是系统进行资源分配和调度的一个独立单位。 一个程序可以对应多个进程（多开），一个进程为多个程序服务（WeGame）。 一个程序执行在不同的数据集上就称为不同的进程，可以通过进程控制块来唯一地标识每一个进程。  进程与线程   进程优点：
 进程提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和资源，可以提高计算机的利用率。
   进程的两个重要缺点：
 进程只能在一个时间做一件事
  进程在执行过程中如果遇到IO，无法执行
   进程间通信   Queue
  pipe
  Managers
  Redis
  进程池  from multiprocessing import Process, Pool import time, os def foo(i): time.</description>
    </item>
    
    <item>
      <title>集合常用方法</title>
      <link>/blog/python/%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 12 Apr 2020 20:31:47 +0800</pubDate>
      
      <guid>/blog/python/%E9%9B%86%E5%90%88%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description> `set() 去重` `intersection()` `union()` `difference()`  </description>
    </item>
    
    <item>
      <title>字典常用方法</title>
      <link>/blog/python/%E5%AD%97%E5%85%B8%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 12 Apr 2020 20:30:03 +0800</pubDate>
      
      <guid>/blog/python/%E5%AD%97%E5%85%B8%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description> `clear()` `setdefault()` `fromkeys()` `keys()` `values()` `items()` `get()` `pop()` `update()`  </description>
    </item>
    
    <item>
      <title>字符串常用方法</title>
      <link>/blog/python/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 12 Apr 2020 20:27:21 +0800</pubDate>
      
      <guid>/blog/python/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description> `find()` `rfind()` `index()` `split()` `join()` `strip()` `lstrip()` `rstrip()` `isalpha()` `isdigit()` `isalnum()` `startswith()` `endswith()` `upper()` `lower()`  </description>
    </item>
    
    <item>
      <title>列表常用方法</title>
      <link>/blog/python/%E5%88%97%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sun, 12 Apr 2020 20:22:01 +0800</pubDate>
      
      <guid>/blog/python/%E5%88%97%E8%A1%A8%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</guid>
      <description> `append()` `extend()` `insert()` `pop()` `remove()` `reverse()` `sort()` `count()` `index()` `enumrate()`  </description>
    </item>
    
    <item>
      <title>Datetime模块</title>
      <link>/blog/python/datetime%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Sun, 12 Apr 2020 18:13:09 +0800</pubDate>
      
      <guid>/blog/python/datetime%E6%A8%A1%E5%9D%97/</guid>
      <description>1. 日期输出格式化 所有日期、时间的api都在datetime模块内。
  datetime =&amp;gt; string
 now = datetime.datetime.now() now.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;)    string =&amp;gt; datetime
 t_str = &#39;2012-03-05 16:26:23&#39; d = datetime.datetime.strptime(t_str, &#39;%Y-%m-%d %H:%M:%S&#39;)    日期比较操作
    在datetime模块中有timedelta类，这个类的对象用于表示一个时间间隔，比如两个日期或者时间的差别。
  构造方法：
 datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)    所有的参数都有默认值0，这些参数可以是int或float，正的或负的。
  可以通过timedelta.days、tiemdelta.seconds等获取相应的时间值。
  timedelta类的实例，支持加、减、乘、除等操作，所得的结果也是timedelta类的实例。比如：
 year = timedelta(days=365) ten_years = year *10 nine_years = ten_years - year    同时，date、time和datetime类也支持与timedelta的加、减运算。</description>
    </item>
    
    <item>
      <title>Pygame中的Surface</title>
      <link>/blog/pygame/11-pygame%E4%B8%AD%E7%9A%84surface/</link>
      <pubDate>Thu, 09 Apr 2020 01:31:53 +0800</pubDate>
      
      <guid>/blog/pygame/11-pygame%E4%B8%AD%E7%9A%84surface/</guid>
      <description>将一个图像绘制到另一个pygame.Surface.blit
将许多图像绘制到另一个pygame.Surface.blits
更改图像的像素格式pygame.Surface.convert
改变包括每像素α的图像的像素格式pygame.Surface.convert_alpha
创建Surface的新副本pygame.Surface.copy
用纯色填充Surfacepygame.Surface.fill
将表面图像移动到位pygame.Surface.scroll
设置透明颜色键pygame.Surface.set_colorkey
获取当前透明的colorkeypygame.Surface.get_colorkey
设置完整Surface图像的Alpha值pygame.Surface.set_alpha
获取当前的Surface透明度值pygame.Surface.get_alpha
锁定Surface内存以进行像素访问pygame.Surface.lock
从像素访问中解锁Surface存储器pygame.Surface.unlock
测试Surface是否需要锁定pygame.Surface.mustlock
测试Surface是否被当前锁定pygame.Surface.get_locked
获取Surface的锁pygame.Surface.get_locks
获取单个像素的颜色值pygame.Surface.get_at
设置单个像素的颜色值pygame.Surface.set_at
获取单个像素的映射颜色值pygame.Surface.get_at_mapped
获取8位Surface的颜色索引调色板pygame.Surface.get_palette
获取调色板中单个条目的颜色pygame.Surface.get_palette_at
设置8位Surface的调色板pygame.Surface.set_palette
在8位Surface调色板中设置单个索引的颜色pygame.Surface.set_palette_at
将颜色转换为映射的颜色值pygame.Surface.map_rgb
将映射的整数颜色值转换为颜色pygame.Surface.unmap_rgb
设置Surface的当前剪切区域pygame.Surface.set_clip
获取Surface的当前剪切区域pygame.Surface.get_clip
创建一个引用其父级的新表面pygame.Surface.subsurface
找到地下的父母pygame.Surface.get_parent
找到地下的顶级父级pygame.Surface.get_abs_parent
在父母中找到子地下的位置pygame.Surface.get_offset
在其顶级父级中查找子级子表面的绝对位置pygame.Surface.get_abs_offset
获取Surface的尺寸pygame.Surface.get_size
获取Surface的宽度pygame.Surface.get_width
获得Surface的高度pygame.Surface.get_height
得到Surface的矩形区域pygame.Surface.get_rect
获取Surface像素格式的位深度pygame.Surface.get_bitsize
获取每个Surface像素使用的字节数pygame.Surface.get_bytesize 
获取用于Surface的其他标志pygame.Surface.get_flags
获取每个Surface行使用的字节数pygame.Surface.get_pitch
位掩码需要在颜色和映射的整数之间进行转换pygame.Surface.get_masks
设置在颜色和映射整数之间转换所需的位掩码pygame.Surface.set_masks
在颜色和映射的整数之间转换所需的位移pygame.Surface.get_shifts
设置在颜色和映射整数之间转换所需的位移pygame.Surface.set_shifts
用于在颜色和映射整数之间进行转换的有效位pygame.Surface.get_losses
找到包含数据的最小rectpygame.Surface.get_bounding_rect
返回Surface像素的缓冲区视图。pygame.Surface.get_view
获取Surface的像素的缓冲对象。pygame.Surface.get_buffer
像素缓冲地址pygame.Surface._pixels_address</description>
    </item>
    
    <item>
      <title>Pygame中的event</title>
      <link>/blog/pygame/06-pygame%E4%B8%AD%E7%9A%84event/</link>
      <pubDate>Thu, 09 Apr 2020 01:29:09 +0800</pubDate>
      
      <guid>/blog/pygame/06-pygame%E4%B8%AD%E7%9A%84event/</guid>
      <description>内部处理pygame事件处理程序pygame.event.pump
从队列中获取事件pygame.event.get
从队列中获取单个事件pygame.event.poll
等待队列中的单个事件pygame.event.wait
测试事件类型是否在队列中等待pygame.event.peek
从队列中删除所有事件pygame.event.clear
从中获取字符串名称和事件IDpygame.event.event_name
控制队列中允许哪些事件pygame.event.set_blocked
控制队列中允许哪些事件pygame.event.set_allowed
测试是否从队列中阻止了某种类型的事件pygame.event.get_blocked 
控制与其他应用程序共享输入设备pygame.event.set_grab
测试程序是否共享输入设备pygame.event.get_grab
在队列上放置一个新事件pygame.event.post
创建一个新的事件对象pygame.event.Event 
用于表示SDL事件的pygame对象pygame.event.EventType</description>
    </item>
    
    <item>
      <title>Pygame中的display</title>
      <link>/blog/pygame/04-pygame%E4%B8%AD%E7%9A%84display/</link>
      <pubDate>Thu, 09 Apr 2020 01:27:58 +0800</pubDate>
      
      <guid>/blog/pygame/04-pygame%E4%B8%AD%E7%9A%84display/</guid>
      <description>初始化显示模块pygame.display.init
取消初始化显示模块pygame.display.quit
如果已初始化显示模块，则返回Truepygame.display.get_init
初始化窗口或屏幕以进行显示pygame.display.set_mode
获取当前设置的显示表面的参考pygame.display.get_surface
将完整显示Surface更新到屏幕pygame.display.flip
更新屏幕的部分以显示软件pygame.display.update
获取pygame显示后端的名称pygame.display.get_driver
创建视频显示信息对象pygame.display.Info
获取有关当前窗口系统的信息pygame.display.get_wm_info
获取可用的全屏模式列表pygame.display.list_modes
为显示模式选择最佳颜色深度pygame.display.mode_ok
获取当前显示的OpenGL标志的值pygame.display.gl_get_attribute
请求显示模式的OpenGL显示属性pygame.display.gl_set_attribute
当显示器在显示器上处于活动状态时返回Truepygame.display.get_active
图标化显示表面pygame.display.iconify
在全屏和窗口显示之间切换pygame.display.toggle_fullscreen
更改硬件伽玛斜坡pygame.display.set_gamma
使用自定义查找更改硬件伽玛斜坡pygame.display.set_gamma_ramp
更改显示窗口的系统图像pygame.display.set_icon
设置当前窗口标题pygame.display.set_caption
获取当前窗口标题pygame.display.get_caption
设置索引显示的显示调色板pygame.display.set_palette</description>
    </item>
    
    <item>
      <title>Pygame中的font</title>
      <link>/blog/pygame/07-pygame%E4%B8%AD%E7%9A%84font/</link>
      <pubDate>Thu, 09 Apr 2020 01:27:09 +0800</pubDate>
      
      <guid>/blog/pygame/07-pygame%E4%B8%AD%E7%9A%84font/</guid>
      <description>初始化字体模块pygame.font.init
取消初始化字体模块pygame.font.quit
如果字体模块已初始化，则为truepygame.font.get_init
获取默认字体的文件名pygame.font.get_default_font
获取所有可用的字体pygame.font.get_fonts
在系统上找到特定的字体pygame.font.match_font
从系统字体创建一个Font对象pygame.font.SysFont
从文件创建一个新的Font对象pygame.font.Font</description>
    </item>
    
    <item>
      <title>Pygame中的key</title>
      <link>/blog/pygame/09-pygame%E4%B8%AD%E7%9A%84key/</link>
      <pubDate>Thu, 09 Apr 2020 01:26:24 +0800</pubDate>
      
      <guid>/blog/pygame/09-pygame%E4%B8%AD%E7%9A%84key/</guid>
      <description>是否显示正在接收来自系统的键盘输入pygame.key.get_focused
获得所有键盘按钮的状态pygame.key.get_pressed
确定哪些修饰符被持有pygame.key.get_mods
临时设置哪些修饰符键被按下pygame.key.set_mods
控件如何重复控制键pygame.key.set_repeat
查看持有的键是如何重复的pygame.key.get_repeat
得到一个键标识符的名称r(63, 63, 63, 0)pygame.key.name</description>
    </item>
    
    <item>
      <title>Pygame中的draw</title>
      <link>/blog/pygame/05-pygame%E4%B8%AD%E7%9A%84draw/</link>
      <pubDate>Thu, 09 Apr 2020 01:25:13 +0800</pubDate>
      
      <guid>/blog/pygame/05-pygame%E4%B8%AD%E7%9A%84draw/</guid>
      <description>画一个矩形的形状pygame.draw.rect
绘制具有任意数量边的形状pygame.draw.polygon
围绕一个点画一个圆圈pygame.draw.circle
在矩形内绘制圆形pygame.draw.ellipse
绘制椭圆的局部剖面pygame.draw.arc
绘制一条直线段pygame.draw.line
绘制多个连续的线段pygame.draw.lines
绘制精细的抗锯齿线pygame.draw.aaline
绘制连接的抗锯齿线序列pygame.draw.aalines</description>
    </item>
    
    <item>
      <title>Pygame中的image</title>
      <link>/blog/pygame/08-pygame%E4%B8%AD%E7%9A%84image/</link>
      <pubDate>Thu, 09 Apr 2020 01:24:50 +0800</pubDate>
      
      <guid>/blog/pygame/08-pygame%E4%B8%AD%E7%9A%84image/</guid>
      <description>从文件加载新图像pygame.image.load
将图像保存到磁盘pygame.image.save
测试是否可以加载扩展图像格式pygame.image.get_extended
将图像传输到字符串缓冲区pygame.image.tostring
从字符串缓冲区创建新的Surfacepygame.image.fromstring
创建一个在字符串缓冲区内共享数据的新Surfacepygame.image.frombuffer</description>
    </item>
    
    <item>
      <title>Pygame中的mouse</title>
      <link>/blog/pygame/10-pygame%E4%B8%AD%E7%9A%84mouse/</link>
      <pubDate>Thu, 09 Apr 2020 01:22:29 +0800</pubDate>
      
      <guid>/blog/pygame/10-pygame%E4%B8%AD%E7%9A%84mouse/</guid>
      <description>得到鼠标按钮的状态信息pygame.mouse.get_pressed
得到鼠标箭头的位置坐标pygame.mouse.get_pos
获取鼠标移动的数量pygame.mouse.get_rel
设置鼠标箭头的位置坐标pygame.mouse.set_pos
隐藏或者显示鼠标箭头pygame.mouse.set_visible
检查程序是否正在接收来自鼠标的数据pygame.mouse.get_focused
为系统鼠标光标设置图像pygame.mouse.set_cursor
获取系统鼠标光标的图像pygame.mouse.get_cursor</description>
    </item>
    
    <item>
      <title>Pygame中的color</title>
      <link>/blog/pygame/03-pygame%E4%B8%AD%E7%9A%84color/</link>
      <pubDate>Thu, 09 Apr 2020 01:21:24 +0800</pubDate>
      
      <guid>/blog/pygame/03-pygame%E4%B8%AD%E7%9A%84color/</guid>
      <description>得到或设置颜色的红色值pygame.Color.r
得到或设置颜色的绿色值pygame.Color.g
得到或设置颜色的蓝色值pygame.Color.b
得到或设置颜色的透明度pygame.Color.a
获取或设置cmy表示颜色pygame.Color.cmy
获取或设置hsva表示的颜色pygame.Color.hsva
获取或设置hsla表示颜色pygame.Color.hsla
获取或设置i1i2i3表示颜色pygame.Color.i1i2i3
返回规范化的RGBA值pygame.Color.normalize
对颜色应用一个特定的伽马值pygame.Color.correct_gamma
将颜色的元素设置为1,2,3或4pygame.Color.set_length</description>
    </item>
    
    <item>
      <title>Pygame中的music</title>
      <link>/blog/pygame/02-pygame%E4%B8%AD%E7%9A%84music/</link>
      <pubDate>Thu, 09 Apr 2020 01:20:17 +0800</pubDate>
      
      <guid>/blog/pygame/02-pygame%E4%B8%AD%E7%9A%84music/</guid>
      <description>加载一个用于播放的音乐文件pygame.mixer.music.load
开始播放音乐流pygame.mixer.music.play
重新启动音乐pygame.mixer.music.rewind
停止播放音乐pygame.mixer.music.stop
暂停音乐播放pygame.mixer.music.pause
恢复暂停的音乐pygame.mixer.music.unpause
在淡出后停止播放音乐pygame.mixer.music.fadeout
设置音量pygame.mixer.music.set_volume
获取音乐音量pygame.mixer.music.get_volume
检查音乐流是否在播放pygame.mixer.music.get_busy
设置的位置pygame.mixer.music.set_pos
获得音乐播放时间pygame.mixer.music.get_pos
队列一个音乐文件以跟随当前pygame.mixer.music.queue
当播放停止时，音乐会发送一个事件pygame.mixer.music.set_endevent
当播放停止时，获取一个通道发送的事件pygame.mixer.music.get_endevent</description>
    </item>
    
    <item>
      <title>05 键值对应关系表</title>
      <link>/blog/%E5%85%B6%E4%BB%96/05-%E9%94%AE%E5%80%BC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E8%A1%A8/</link>
      <pubDate>Thu, 09 Apr 2020 00:40:45 +0800</pubDate>
      
      <guid>/blog/%E5%85%B6%E4%BB%96/05-%E9%94%AE%E5%80%BC%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB%E8%A1%A8/</guid>
      <description>KeyASCII ASCII Common Name     KeyASCII ASCII Common Name   K_BACKSPACE \b backspace   K_TAB \t tab   K_CLEAR  clear   K_RETURN \r return   K_PAUSE  pause   K_ESCAPE ^[ escape   K_SPACE  space   K_EXCLAIM ! exclaim   K_QUOTEDBL &amp;quot; quotedbl   K_HASH # hash   K_DOLLAR $ dollar   K_AMPERSAND &amp;amp; ampersand   K_QUOTE  quote   K_LEFTPAREN ( left parenthesis   K_RIGHTPAREN ) right parenthesis   K_ASTERISK * asterisk   K_PLUS + plus sign   K_COMMA , comma   K_MINUS - minus sign   K_PERIOD .</description>
    </item>
    
    <item>
      <title>Random模块</title>
      <link>/blog/python/random%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Thu, 09 Apr 2020 00:27:13 +0800</pubDate>
      
      <guid>/blog/python/random%E6%A8%A1%E5%9D%97/</guid>
      <description>random 是 Python 内置的一个模块，包括以下方法：
 初始化伪随机数生成器。如果未提供as或者a=None，则使用系统时间为种子。如果a是一个整数，则作为种子。  random.seed(a=None, version=2)
 返回一个当前生成器的内部状态的对象  random.getstate()
 传入一个先前利用getstate方法获得的状态对象，使得生成器恢复到这个状态。  random.setstate(state)
 返回range(0,2**k)之间的一个整数，相当于randrange(0,\2**k)  random.getrandbits(k)
 返回range(0,stop)之间的一个整数  random.randrange(stop)
 返回range[start,stop)之间的一个整数，可加step，跟range(0,10,2)类似  random.randrange(start, stop[, step])
 返回range[a,b]之间的一个整数，等价于然的range(a,b+1)  random.randint(a, b)
 从非空序列seq中随机选取一个元素。如果seq为空则弹出 IndexError异常。  random.choice(seq)
 3.6版本新增。从population集群中随机抽取K个元素（可重复）。weights是相对权重列表，cum_weights是累计权重，两个参数不能同时存在。  random.choices(population, weights=None, *, cum_weights=None, k=1)
 随机打乱序列x内元素的排列顺序。只能针对可变的序列，对于不可变序列，请使用下面的sample()方法。  random.shuffle(x[, random])
 从population样本或集合中随机抽取K个不重复的元素形成新的序列。常用于不重复的随机抽样。返回的是一个新的序列，不会破坏原有序列。要从一个整数区间随机抽取一定数量的整数，请使用sample(range(10000000), k=60)类似的方法，这非常有效和节省空间。如果k大于population的长度，则弹出ValueError异常。  random.sample(population, k)
 返回一个介于左闭右开[0.0, 1.0)区间的浮点数  random.random()
 返回一个介于a和b之间的浮点数。如果a&amp;gt;b，则是b到a之间的浮点数。这里的a和b都有可能出现在结果中。  random.uniform(a, b)</description>
    </item>
    
    <item>
      <title>Pygame初始化</title>
      <link>/blog/pygame/01-pygame%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Wed, 08 Apr 2020 19:51:49 +0800</pubDate>
      
      <guid>/blog/pygame/01-pygame%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>这是一套pygame的自用初始化模板，这个“游戏”的唯一功能就是按方向键的时候，“退出游戏”按钮可以动。
#初始化 import pygame,sys,configparser from pygame.locals import * pygame.init() #载入脚本 parser = configparser.ConfigParser() parser.read(&#39;rules.ini&#39;, encoding=&#39;gbk&#39;) #设置帧率 Fps = 60 fpsClock = pygame.time.Clock() #创建窗口 WindowsWidth = 1920 WindowsHeight = 1080 DisplaySurf = pygame.display.set_mode((WindowsWidth,WindowsHeight),FULLSCREEN|HWSURFACE,32) pygame.set_caption = &#39;初始化&#39; #颜色管理 White = (255,255,255,0) Green = (100,210,100,0) Blue = (100,100,210,50) Black = (0,0,0,0) Orange = (210,150,50,0) #设置背景 DisplaySurf.fill(White) #导入图片 coverImg = pygame.image.load(&#39;cover.png&#39;).convert_alpha() btStartGame = pygame.image.load(&#39;bt001.png&#39;).convert_alpha() btExitGame = pygame.image.load(&#39;bt002.png&#39;) CoverGlass = pygame.image.load(&#39;glass.png&#39;) cursorImg = pygame.image.load(&#39;cursor.png&#39;).convert_alpha() cursorLinkImg = pygame.</description>
    </item>
    
    <item>
      <title>Py转exe</title>
      <link>/blog/%E5%85%B6%E4%BB%96/04-py%E8%BD%ACexe/</link>
      <pubDate>Wed, 08 Apr 2020 19:44:46 +0800</pubDate>
      
      <guid>/blog/%E5%85%B6%E4%BB%96/04-py%E8%BD%ACexe/</guid>
      <description>py是解释型语言，只能在配有python的环境下才能运行，只有将py文件打包，才能在更多系统中运行。
py转exe pyinstaller -F --icon=my.ico XXXX.py
 –icon=图标路径（）
-F 打包成一个exe文件
-w 使用窗口，无控制台
-c 使用控制台，无窗口
-D 创建一个目录，里面包含exe以及其他一些依赖性文件
 pyqt5写完win32 应用程序后，经过pyinstaller打包成单个文件，运行弹出错误提示框：
failed to execute script main
pycharm中pyinstaller打包参数：
Program:C:\Python\Python35\Scripts\pyinstaller.exe
Parameters: -w -F $FileName$
Working directory: $FileDir$
分析： 经google，发现pyinstaller 有&amp;ndash;hidden-import 选项 &amp;ndash;hidden-import MODULENAME, &amp;ndash;hiddenimport MODULENAME Name an import not visible in the code of the script(s). This option can be used multiple times.
解决： 打包时加上 --hidden-import=queue
即Parameters配置修改为：
Parameters:--hidden-import=queue -w -F $FileName$
eg:
pyinstaller --hidden-import=queue -w -F main.</description>
    </item>
    
    <item>
      <title>数据库Redis操作</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/02-%E6%95%B0%E6%8D%AE%E5%BA%93redis%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 08 Apr 2020 15:08:30 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/02-%E6%95%B0%E6%8D%AE%E5%BA%93redis%E6%93%8D%E4%BD%9C/</guid>
      <description>Redis的详细操作方法，针对五种不同数据类型的增删改查
 String 字符串类型的数据存取
set(name, value, ex=None, px=None, nx=False, xx=False)
 相关参数：
 ex，过期时间（秒）
px，过期时间（毫秒）
nx，如果设置为True，则只有name不存在时，当前set操作才执行
xx，如果设置为True，则只有name存在时，当前set操作才执行
  r.set(&#39;name&#39;, &#39;Issac&#39;) # key是&amp;quot;foo&amp;quot; value是&amp;quot;bar&amp;quot; 将键值对存入redis缓存 r.get(&#39;name&#39;)    只有name不存在时，才执行set操作（添加）
 r.setnx(name, value) print(r.setnx(&#39;name&#39;, &#39;Issac&#39;)) # fruit1不存在，输出为True，存在输出为None    time，过期时间（int秒 或 timedelta对象）,psetex()的参数相同，单位是毫秒。
r.setex(name, time, value)
  批量设置
 r.mget({&#39;k1&#39;: &#39;v1&#39;, &#39;k2&#39;: &#39;v2&#39;}) r.mset(name = &amp;quot;issac&amp;quot;, age=26, height=190)    批量获取
r.mget(&#39;name&#39;, &#39;age&#39;, &#39;height&#39;)
  设置新值并获取原来的值
print(r.getset(&amp;quot;name&amp;quot;, &amp;quot;Missty&amp;quot;)) # 设置的新值是Missty 设置前的值是Issac</description>
    </item>
    
    <item>
      <title>Redis配置</title>
      <link>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/01-%E6%95%B0%E6%8D%AE%E5%BA%93redis%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 08 Apr 2020 14:47:44 +0800</pubDate>
      
      <guid>/blog/%E6%95%B0%E6%8D%AE%E5%BA%93/01-%E6%95%B0%E6%8D%AE%E5%BA%93redis%E9%85%8D%E7%BD%AE/</guid>
      <description>Redis是一个开源的使用ANSIC语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。
 特点  redis最大的特点在于其效率极高。
   读的速度是110000次/s
写的速度是81000次/s。
   支持多种数据结构
   string（字符串）
list(双向链表)
dict(hash表)
set(集合）
zset(有序集合)
   支持持久化操作
 局限性  Redis只能使用单线程，性能受限于CPU性能 Mc和Redis都是Key-Value类型，不适合在不同数据集之间建立关系，也不适合进行查询搜索。
 Python与Redis的交互操作，借用python中的redis模块。
import redis
该模块中封装的方法名称、使用规则与原生的redis语法几乎一致。
定义地址和端口 host = &#39;127.0.0.1&#39; port = 6379  建立redis连接 r = redis.Redis(host=host,port=port)  </description>
    </item>
    
    <item>
      <title>Django常用的工具方法</title>
      <link>/blog/django/07-django%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/</link>
      <pubDate>Wed, 08 Apr 2020 13:54:16 +0800</pubDate>
      
      <guid>/blog/django/07-django%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B7%A5%E5%85%B7%E6%96%B9%E6%B3%95/</guid>
      <description>原生sql结果集美化，获取ip，redis链接，验证token，类方法装饰器，七牛云秘钥接口，立体中文水印，PIL绘制验证码，MD5加密方法
 Django中复用率较高的代码
针对原生sql语句的结果集美化方法 from pymongo import MongoClient m = MongoClient() md_db = m.mdshop # 对结果集美化方法 def dict_fetchall(cursor): # 获取游标描述 desc = cursor.description return [ dict(zip( [col[0] for col in desc], row )) for row in cursor.fetchall() ]  获取ip # 获取ip def getIp(request): # 获取IP if &#39;HTTP_X_FORWARDED_FOR&#39; in request.META: ip = request.META(&#39;HTTP_X_FORWARDED_FOR&#39;) else: ip = request.META.get(&#39;REMOTE_ADDR&#39;) return ip  redis链接 import redis # 定义ip 和端口 host = &#39;127.0.0.1&#39; port = 6379 # 建立连接 r = redis.</description>
    </item>
    
    <item>
      <title>Django操作Mysql</title>
      <link>/blog/django/06-django%E6%93%8D%E4%BD%9Cmysql/</link>
      <pubDate>Wed, 08 Apr 2020 12:08:08 +0800</pubDate>
      
      <guid>/blog/django/06-django%E6%93%8D%E4%BD%9Cmysql/</guid>
      <description>Django中orm框架的使用方法，包括数据库的增删改查，对结果集的处理。
 数据库的增删改查，在orm下的实现方法
1. 增加   save()  user = User(username=&#39;Issac&#39;, password=&#39;123&#39;) user.save()    create()  User.objects.create(username=&#39;Missty&#39;, password=&#39;456&#39;)     2. 删除   delete()  User.objects.get(id=1).delete()     3. 修改   save()  user = User.objects.filter(name=&#39;Issac&#39;).first() user.name=&#39;Loveless&#39; user.save()    update()  User.objects.filter(name=&#39;Arissa&#39;).update(name=&#39;Inverse&#39;)    4. 查询 4.1 基本查询   get()    如果不存在会抛出模型类.DoesNotExist异常
  User.objects.get(id=1)    all()  User.</description>
    </item>
    
    <item>
      <title>Django配置MySql</title>
      <link>/blog/django/05-django%E9%85%8D%E7%BD%AEmysql/</link>
      <pubDate>Wed, 08 Apr 2020 10:23:18 +0800</pubDate>
      
      <guid>/blog/django/05-django%E9%85%8D%E7%BD%AEmysql/</guid>
      <description>Django 中的orm框架如何实现MySql数据库的增删改查，更新了自动添加创建时间的功能
 1. 数据库配置 在settings.py中的DATABASE里保存了数据库的连接配置信息。
使用MySQL数据库首先需要安装驱动程序。 pip install PyMySQL
在Django的工程同名子目录的__init__.py文件中添加如下语句 from pymysql import install_as_MySQLdb install_as_MySQLdb()  作用是让Django的ORM能以mysqldb的方式来调用PyMySQL。
修改DATABASES配置信息 DATABASES = { &#39;default&#39;: { &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;, &#39;HOST&#39;: &#39;127.0.0.1&#39;, # 数据库主机 &#39;PORT&#39;: 3306, # 数据库端口 &#39;USER&#39;: &#39;root&#39;, # 数据库用户名 &#39;PASSWORD&#39;: &#39;mysql&#39;, # 数据库用户密码 &#39;NAME&#39;: &#39;django_demo&#39; # 数据库名字 } }  在MySQL中创建数据库 create database django_demo default charset=utf8;   2. Models 定义模型类
 模型类被定义在&amp;quot;应用/models.py&amp;quot;文件中。 模型类必须继承自Model类，位于包django.db.models中。  1) 定义 在models.py中定义模型 orm框架：创建表和字段
from django.db import models #定义用户模型类User class User(models.</description>
    </item>
    
    <item>
      <title>Django的请求与响应</title>
      <link>/blog/django/04-django%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/</link>
      <pubDate>Wed, 08 Apr 2020 09:22:50 +0800</pubDate>
      
      <guid>/blog/django/04-django%E7%9A%84%E8%AF%B7%E6%B1%82%E4%B8%8E%E5%93%8D%E5%BA%94/</guid>
      <description>请求request和响应response
 1, 请求 GET和POST请求 request中包含GET和POST属性，来接收相应请求方法传来的数据。
from django.views import View class Sample(View): def get(self, request): # 获取参数 params = request.GET params.get(key) def post(self, request): # 获取参数 data = request.POST params.get(key)  其他请求 这种方式是解析request.body，泛用性很高。
from django.views import View class Sample(View): def put(self,request): # 整理数据 put = QueryDict(request.body) put_str = list(put.items())[0][0] put_dict = eval(put_str).get(&#39;data&#39;) # 获取参数 put_dict.get(key)  请求头  CONTENT_LENGTH – The length of the request body (as a string). CONTENT_TYPE – The MIME type of the request body.</description>
    </item>
    
    <item>
      <title>Django的配置</title>
      <link>/blog/django/03-django%E7%9A%84%E9%85%8D%E7%BD%AE/</link>
      <pubDate>Wed, 08 Apr 2020 09:07:05 +0800</pubDate>
      
      <guid>/blog/django/03-django%E7%9A%84%E9%85%8D%E7%BD%AE/</guid>
      <description>配置文件settings中的一些基础设置。
 1. 配置文件 Django将环境变量集成在settings.py中，可以在该文件里修改相关的配置。
1) BASE_DIR BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
当前工程的根目录，Django会依此来定位工程内的相关文件，我们也可以使用该参数来构造文件路径。
2) DEBUG 调试模式，创建工程后初始值为True，即默认工作在调试模式下。
 修改代码文件，程序自动重启 Django程序出现异常时，向前端显示详细的错误追踪信息 注意：部署线上运行的Django不要运行在调式模式下，记得修改DEBUG=False。  3) 语言与时区 Django支持本地化处理，即显示语言与时区支持本地化。初始化的工程默认语言和时区为英语和UTC标准时区，中国大陆地区使用简体中文，时区使用亚洲/上海时区，注意这里不使用北京时区表示。
LANGUAGE_CODE = &#39;zh-hans&#39; TIME_ZONE = &#39;Asia/Shanghai&#39;   2. 静态文件 项目中的CSS、图片、js都是静态文件。一般会将静态文件放到一个单独的目录中，以方便管理。
在html页面中调用时，也需要指定静态文件的路径，Django中提供了一种解析的方式配置静态文件路径。静态文件可以放在项目根目录下，也可以放在应用的目录下，由于有些静态文件在项目中是通用的，所以推荐放在项目的根目录下，方便管理。
为了提供静态文件，需要配置两个参数：
  STATICFILES_DIRS 存放查找静态文件的目录
  STATIC_URL 访问静态文件的URL前缀
STATIC_URL = &amp;lsquo;/static/&amp;rsquo; STATICFILES_DIRS = [ os.path.join(BASE_DIR, &amp;lsquo;static_files&amp;rsquo;), ]
  此时在static_files添加的任何静态文件都可以使用网址/static/文件在static_files中的路径来访问。
例如： http://localhost:8000/static/logo.png
 注意
  Django 仅在调试模式下（DEBUG=True）能对外提供静态文件。
  当DEBUG=False工作在生产模式时，Django不再对外提供静态文件，需要是用collectstatic命令来收集静态文件并交由其他静态文件服务器来提供。
  </description>
    </item>
    
    <item>
      <title>Django初始化</title>
      <link>/blog/django/02-django%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B/</link>
      <pubDate>Wed, 08 Apr 2020 08:36:40 +0800</pubDate>
      
      <guid>/blog/django/02-django%E5%88%9B%E5%BB%BA%E5%B7%A5%E7%A8%8B/</guid>
      <description>Django初始化一个项目要进行的素质三连
 1. 创建项目 创建工程的命令为：
django-admin startproject 工程名称
运行开发服务器 在开发阶段，为了能够快速预览到开发的效果，django提供了一个纯python编写的轻量级web服务器，仅在开发阶段使用。
运行服务器命令为：
python manage.py runserver ip:端口 或： python manage.py runserver  可以不写IP和端口，默认IP是127.0.0.1，默认端口为8000。
 django默认工作在调式Debug模式下，如果增加、修改、删除文件，服务器会自动重启。 按ctrl+c停止服务器。   2. 创建子应用 在Web应用中，通常有一些业务功能模块是在不同的项目中都可以复用的，故在开发中通常将工程项目拆分为不同的子功能模块，各功能模块间可以保持相对的独立，在其他工程项目中需要用到某个特定功能模块时，可以将该模块代码整体复制过去，达到复用。
类似于Flask中的蓝图Blueprint。
Django的视图编写是放在子应用中的。
创建 python manage.py startapp 子应用名称
manage.py 为上述创建工程时自动生成的管理文件。
 admin.py 文件跟网站的后台管理站点配置相关。 apps.py 文件用于配置当前子应用的相关信息。 migrations 目录用于存放数据库迁移历史文件。 models.py 文件用户保存数据库模型类。 tests.py 文件用于开发测试用例，编写单元测试。 views.py 文件用于编写Web应用视图。  注册安装子应用 创建出来的子应用目录文件虽然被放到了工程项目目录中，但是django工程并不能立即直接使用该子应用，需要注册安装后才能使用。
在工程配置文件settings.py中，INSTALLED_APPS项保存了工程中已经注册安装的子应用。注册安装一个子应用的方法，即是将子应用的配置信息文件apps.py中的Config类添加到INSTALLED_APPS列表中。
例如，将刚创建的users子应用添加到工程中，可在INSTALLED_APPS列表中添加&amp;rsquo;users.apps.UsersConfig&amp;rsquo;。
 3. 创建视图 Django的视图是定义在子应用的views.py中的。
创建 打开刚创建的users模块，在views.py中编写视图代码。
from django.http import HttpResponse def index(request): &amp;quot;&amp;quot;&amp;quot; :request: 包含了请求信息的请求对象 :return: 响应对象 &amp;quot;&amp;quot;&amp;quot; return HttpResponse(&amp;quot;hello the world!</description>
    </item>
    
    <item>
      <title>虚拟环境</title>
      <link>/blog/%E5%85%B6%E4%BB%96/03-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</link>
      <pubDate>Wed, 08 Apr 2020 08:27:39 +0800</pubDate>
      
      <guid>/blog/%E5%85%B6%E4%BB%96/03-%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/</guid>
      <description>虚拟环境是在计算机硬盘中独立开辟出的一部分空间，在这里可以安装和外部环境不同版本的框架，不与外界冲突。
 虚拟环境是在计算机硬盘中独立开辟出的一部分空间，在这里可以安装和外部环境不同版本的框架，不与外界冲突。针对于需要不同版本环境的项目，可以搭建相应的虚拟环境。
1. 创建虚拟环境 mkvirtualenv django_py3_1.11 -p python3
2. 虚拟环境常用指令 # 虚拟环境 mkvirtualenv # 创建虚拟环境 rmvirtualenv # 删除虚拟环境 workon # 进入虚拟环境、查看所有虚拟环境 deactivate # 退出虚拟环境 </description>
    </item>
    
    <item>
      <title>Django介绍</title>
      <link>/blog/django/01-django%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Wed, 08 Apr 2020 08:13:14 +0800</pubDate>
      
      <guid>/blog/django/01-django%E4%BB%8B%E7%BB%8D/</guid>
      <description>Django在近年来的迅速发展，应用越来越广泛，被著名IT开发杂志SDTimes评选为2013SDTimes100，位列&amp;quot;API、库和框架&amp;quot;分类第6位，被认为是该领域的佼佼者。
 1. 简介 Django，发音为[`dʒæŋɡəʊ]，是用python语言写的开源web开发框架，并遵循MVC设计。劳伦斯出版集团为了开发以新闻内容为主的网站，而开发出来了这个框架，于2005年7月在BSD许可证下发布。这个名称来源于比利时的爵士音乐家DjangoReinhardt，他是一个吉普赛人，主要以演奏吉它为主，还演奏过小提琴等。由于Django在近年来的迅速发展，应用越来越广泛，被著名IT开发杂志SDTimes评选为2013SDTimes100，位列&amp;quot;API、库和框架&amp;quot;分类第6位，被认为是该领域的佼佼者。
Django的主要目的是简便、快速的开发数据库驱动的网站。它强调代码复用，多个组件可以很方便的以&amp;quot;插件&amp;quot;形式服务于整个框架，Django有许多功能强大的第三方插件，你甚至可以很方便的开发出自己的工具包。这使得Django具有很强的可扩展性。它还强调快速开发和DRY(DoNotRepeatYourself)原则。
 2. 特点  提供项目工程管理的自动化脚本工具 数据库ORM支持（对象关系映射，英语：Object Relational Mapping） 模板 表单 Admin管理站点 文件管理 认证权限 session机制 缓存   本博客提供的Django教程为前后端开发。结合vue使用的部分，且为no_session系统。于此无关者一切从简。
# 点击查看Django文档 </description>
    </item>
    
    <item>
      <title>Markdown语法简介</title>
      <link>/blog/%E5%85%B6%E4%BB%96/02-markdown%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Tue, 07 Apr 2020 23:33:18 +0800</pubDate>
      
      <guid>/blog/%E5%85%B6%E4%BB%96/02-markdown%E8%AF%AD%E6%B3%95%E7%AE%80%E4%BB%8B/</guid>
      <description>MarkDown
 Markdown 的超简短语法介绍 标题 普通文字
图片 本地图片 ![logo](/logo.png)
网络图片 ![logo](https://i01piccdn.sogoucdn.com/e176b93079818948)
链接 [本站](https://www.missbless.cn)
本站
代码 `code`单行代码  或者缩进标识多行代码
code
 code  MarkDown 的 11 种基本语法   标题设置（让字体变大，和word的标题意思一样） 在Markdown当中设置标题，有两种方式： 第一种：通过在文字下方添加“=”和“-”，他们分别表示一级标题和二级标题。 第二种：在文字开头加上 “#”，通过“#”数量表示几级标题。（一共只有1~6级标题，1级标题字体最大）
  块注释（blockquote） 通过在文字开头添加“&amp;gt;”表示块注释。（当&amp;gt;和文字之间添加五个blank时，块注释的文字会有变化。）
  斜体 将需要设置为斜体的文字两端使用1个“*”或者“_”夹起来
  粗体 将需要设置为斜体的文字两端使用2个“*”或者“_”夹起来
  无序列表 在文字开头添加(, +, and -)实现无序列表。但是要注意在(, +, and -)和文字之间需要添加空格。（建议：一个文档中只是用一种无序列表的表示方式）
  有序列表 使用数字后面跟上句号。（还要有空格）
  链接（Links）
Markdown中有两种方式，实现链接，分别为内联方式和引用方式。
内联方式：This is an example link.
引用方式：
 I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3].</description>
    </item>
    
    <item>
      <title>Hugo博客编撰日志</title>
      <link>/blog/%E5%85%B6%E4%BB%96/01-hugo%E5%8D%9A%E5%AE%A2%E7%BC%96%E6%92%B0%E6%97%A5%E5%BF%97/</link>
      <pubDate>Tue, 07 Apr 2020 23:20:16 +0800</pubDate>
      
      <guid>/blog/%E5%85%B6%E4%BB%96/01-hugo%E5%8D%9A%E5%AE%A2%E7%BC%96%E6%92%B0%E6%97%A5%E5%BF%97/</guid>
      <description>该博客的撰写轨迹
 创建新项目 hugo new site missbless
 下载主题 https://themes.gohugo.io/
如果是手动下载，解压缩后删除文件夹后面的 -master
 配置主题 进入\themes\hugo-future-imperfect-slim\exampleSite，复制 data, resources, static, config.toml 到根目录
 启动项目 hugo server
 创建文件 hugo new 文件夹/文件名.md
 MarkDown语法 MarkDown语法
 修改默认设置 修改archetypes/default.md，来编辑默认的模板
 自动生成目录 &#39;&#39;&#39; 这个脚本用来实现自动生成分级目录，项目打包，自动替换打包后的简历文件，配置代理并上传到github &#39;&#39;&#39; import os dir_list = os.listdir(&#39;./content/blog/&#39;) dir_list.remove(&#39;其他&#39;) dir_list.append(&#39;其他&#39;) from datetime import datetime # 写入头部 date = &amp;quot;%sT%s&amp;quot;%(datetime.now().date(), datetime.now().time()) date = date.split(&#39;.&#39;,-1)[0] + &#39;+08:00&#39; head = &amp;quot;---\ntitle: &#39;Contents&#39;\ndate: %s\n---\n&amp;quot;%date with open(&#39;./content/Contents.md&#39;, &#39;w&#39;, encoding=&#39;utf-8&#39;) as f: f.</description>
    </item>
    
    <item>
      <title>Git常用指令</title>
      <link>/blog/git/01-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</link>
      <pubDate>Mon, 06 Apr 2020 20:35:10 +0800</pubDate>
      
      <guid>/blog/git/01-git%E5%B8%B8%E7%94%A8%E6%8C%87%E4%BB%A4/</guid>
      <description>git config --system --unset credential.helper
清空账户密码配置
git config --global credential.helper store
保存账户密码
git checkout .
没有add的时候回退修改
git reset HEAD
add到暂存区之后回退
git log
复制第二个id
git reset --hard
粘贴
git commit之后回退</description>
    </item>
    
    <item>
      <title>Git配置代理</title>
      <link>/blog/git/02-git%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</link>
      <pubDate>Mon, 06 Apr 2020 20:30:12 +0800</pubDate>
      
      <guid>/blog/git/02-git%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86/</guid>
      <description>配置代理：
git config --global http.proxy http://127.0.0.1:1087
git config --global https.proxy https://127.0.0.1:1087
解除配置
git config --global --unset http.proxy
git config --global --unset https.proxy</description>
    </item>
    
    <item>
      <title>git解决push问题</title>
      <link>/blog/git/03-git%E8%A7%A3%E5%86%B3push%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 06 Apr 2020 19:00:52 +0800</pubDate>
      
      <guid>/blog/git/03-git%E8%A7%A3%E5%86%B3push%E9%97%AE%E9%A2%98/</guid>
      <description>&#39;&amp;rsquo;&amp;rsquo; hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: &amp;lsquo;git pull &amp;hellip;&#39;) before pushing again. hint: See the &amp;lsquo;Note about fast-forwards&amp;rsquo; in &amp;lsquo;git push &amp;ndash;help&amp;rsquo; for details.
解决办法： git push -u origin master -f</description>
    </item>
    
    <item>
      <title></title>
      <link>/blog/pygame/pygame%E4%B8%AD%E7%9A%84image/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>/blog/pygame/pygame%E4%B8%AD%E7%9A%84image/</guid>
      <description>从文件加载新图像pygame.image.load
将图像保存到磁盘pygame.image.save
测试是否可以加载扩展图像格式pygame.image.get_extended
将图像传输到字符串缓冲区pygame.image.tostring
从字符串缓冲区创建新的Surfacepygame.image.fromstring
创建一个在字符串缓冲区内共享数据的新Surfacepygame.image.frombuffer
从文件加载新图像pygame.image.load
将图像保存到磁盘pygame.image.save
测试是否可以加载扩展图像格式pygame.image.get_extended
将图像传输到字符串缓冲区pygame.image.tostring
从字符串缓冲区创建新的Surfacepygame.image.fromstring
创建一个在字符串缓冲区内共享数据的新Surfacepygame.image.frombuffer</description>
    </item>
    
  </channel>
</rss>